<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[qs 序列化数据使用]]></title>
    <url>%2F2019%2F12%2F11%2Fqs%2F</url>
    <content type="text"><![CDATA[React、Vue在接口获取传输数据使用qs进行数据序列化遇到问题，后台查询列表需要拼接带’.‘的参数。 如果参数中存在’.‘需要添加allowDots属性,允许 dots： 1qs.stringify(params, &#123;allowDots: true&#125;) qs参考地址 https://github.com/ljharb/qs]]></content>
      <categories>
        <category>qs</category>
      </categories>
      <tags>
        <tag>qs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker离线安装Nginx镜像]]></title>
    <url>%2F2019%2F08%2F13%2F2019-8-13-DockerNginx%2F</url>
    <content type="text"><![CDATA[离线安装还Docker后，在离线安装一个Nginx镜像，实现的方法，首先要在有网的地方将nginx镜像导出，然后在复制到内网环境中安装。 在有网环境中将镜像打包 先去pull一个最新的nginx镜像 1docker pull nginx 然后将镜像导出 12docker save e445ab08b2be -o /Users/zhouyanwei/Desktop/nginx.tar 镜像的ID 保存的本地目录+文件名.tar 然后在本地会有生成一个打包好nginx.tar文件（或者上面自定义的名字）。 在专网环境中安装 把这个压缩包放到内网中执行 1docker load -i nginx.tar 然后docker images 看一下当前的镜像 此时 REPOSITORY 和 TAG 都为none 在重新标记下标记一下就好了 1docker tag e445ab08b2be nginx:latest 然后docker images 看一下当前的镜像 启动一个ngixn容器1docker run --name nginx -d -p 8090:80 nginx 第一个 nginx 容器名称。-d设置容器在在后台一直运行。-p 端口进行映射，将本地 8090 端口映射到容器内部的 80 端口。 可能会遇见的错误 解决办法，是因为selinux开启导致docker run失败。 1vim /etc/selinux/config 把 SELINUX项修改为disabled，然后重启CentOS系统。 重启后在执行启动命令就成功了。 1docker start nginx 此时我们在浏览器中访问当前地址加端口号就能访问成功了。 部署 nginx 单单是把nginx启动了并不是我们的最终目的，最起码我们有一个存放文件的地方，还要能修改conf文件，还要能看log吧。 首先创建ngixn目录，在目录下分别创建这三个目录进行存放。 www: 目录将映射为 nginx 容器配置的虚拟目录。logs: 目录将映射为 nginx 容器的日志目录。conf: 目录里的配置文件将映射为 nginx 容器的配置文件。 1mkdir -p ~/nginx/www ~/nginx/logs ~/nginx/conf 此时会在root文件夹下创建nginx文件夹，下面有三个文件夹。其他账户登录要去home文件夹下当前登录的用户文件夹下查找。 然后我们将当前ngixn默认的配置文件拷贝到我没呢新建的nginx/conf文件夹下。 12docker cp 01d9251b8255:/etc/nginx/nginx.conf ~/nginx/conf/ 容器id,可使用 docker ps 查看 在重新部署nginx 1docker run -d -p 80:80 --name nginxpro -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/nginx/logs:/var/log/nginx nginx -p 80:80： 将容器的 80 端口映射到主机的 80 端口。–name nginxpro：将容器命名为 nginxpro。-v ~/nginx/www:/usr/share/nginx/html：将我们自己创建的 www 目录挂载到容器的 /usr/share/nginx/html。-v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf：将我们自己创建的 nginx.conf 挂载到容器的 /etc/nginx/nginx.conf。-v ~/nginx/logs:/var/log/nginx：将我们自己创建的 logs 挂载到容器的 /var/log/nginx。 然后我们进www文件目录创建一个index.html。 1vim ~/nginx/www/index.html 12 月 2 日更新。遇到的问题 如何添加代理 docker中的nginx配置文件不单只是一个nginx.conf 先执行命令进nginx交互模式里看一下nginx的结构 要把自己创建的目录和容器对应上才可以。 所以还需要重新部署ngixn 12345docker run -d -p 80:80 --name nginx \ -v ~/nginx/www:/usr/share/nginx/html \ -v ~/nginx/nginx.conf:/etc/nginx/nginx.conf \ -v ~/nginx/conf.d:/etc/nginx/conf.d \ -v ~/nginx/logs:/var/log/nginx nginx 在default.conf重设置代理就可以生效了。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux离线安装Docker]]></title>
    <url>%2F2019%2F08%2F12%2F2019-8-12-LinuxDocker%2F</url>
    <content type="text"><![CDATA[如何在Linux离线下进行Docker安装。 本地环境 Linux版本：CentOS 7.6 Docker版本：docker-19.03.1 官方下载地址 安装步骤首先把下载好的Docker压缩包放到Linux根目录中执行解压命令将压缩包进行解压到指定目录12tar zxvf docker-19.03.1.tarsudo cp docker/* /usr/bin/ 小提示 安装好后不要忘记把根目录的压缩包删除，回到根目录执行命令 rm -f docker-19.03.1.tar要是可以直接ssh的，可以直接在本地把压缩包解压，然后把docker目录直接拽过去就好。 执行启动命令1sudo dockerd 然后查看一下docker版本号是否有了。docker -v 将docker注册为service 新建docker.service文件 1vim /etc/systemd/system/docker.service 把下面的内容复制进去 123456789101112131415161718192021222324252627282930313233[Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target[Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerdExecReload=/bin/kill -s HUP $MAINPID# Having non-zero Limit*s causes performance problems due to accounting overhead# in the kernel. We recommend using cgroups to do container-local accounting.LimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinity# Uncomment TasksMax if your systemd version supports it.# Only systemd 226 and above support this version.#TasksMax=infinityTimeoutStartSec=0# set delegate yes so that systemd does not reset the cgroups of docker containersDelegate=yes# kill only the docker process, not all processes in the cgroupKillMode=process# restart the docker process if it exits prematurelyRestart=on-failureStartLimitBurst=3StartLimitInterval=60s[Install]WantedBy=multi-user.target 执行命令 添加文件权限并启动docker 1chmod +x /etc/systemd/system/docker.service 重载unit配置文件 1systemctl daemon-reload 启动Docker 1systemctl start docker 设置开机自启 1systemctl enable docker.service 常用命令 重启docker 1systemctl restart docker 关闭docker 1systemctl stop docker]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins + publish over ssh 插件进行web前端自动化打包和部署]]></title>
    <url>%2F2019%2F05%2F20%2F2019-5-20-Jenkins%2F</url>
    <content type="text"><![CDATA[好久没有有更新了，换个工作一直忙，今天研究了一下前端测试环境自动化部署，再次记录，方便以后查阅。 安装 Jenkins第一步就是先安装Jenkins，这里以mac系统为例，实际都是大同小异的。 通过 homebrew 安装 Jenkins, 建议通过命令安装，如果使用安装包安装，会涉及到权限问题服务启动不了。 1brew install jenkins 如果没有安装homebrew，请参考这里https://brew.sh/index_zh-cn 安装好了之后执行命令 1jenkins 浏览器访问,进入页面稍等一会。 1[http://localhost:8080](http://localhost:8080) 因为我在安装的时候忘记截图了，所以就盗用了别人的图。 首先按照他的路径找到密码粘贴进去。 然后创建一个用户，方便以后好登陆。 在配置最后一个页面就可以了。 记得还有一个选择插件的页面，用默认的就好了。 建一个item进行自动化打包进入jenkins主页面是这样的。 点击新建item 确定后进入配置页面 General配置 源码管理配置 因为我们目前还在使用svn，所以选择SVN，马上要开新项目，要使git了，配置应该不会有太大变化。 构建触发器配置 这个就看自己的需要了。 构建环境配置 构建配置 注意一下红色提示 此处配置完成后就可以进行build打包了。 然后我们进入jenkins目录文件，就可以看见项目和打包好的dist文件夹了。我的目录是 /Users/zhouyanwei/.jenkins/workspace/test 到此已经实现了自动化打包，接下来就是配置如何实现自动化上传到测试服务器上。 publish over ssh 插件进行自动化部署首先我们先安装插件，因为我已经安装了。 安装好了之后进行Publish over SSH配置 找到 Publish over SSH 项 在进行SSH配置的时候，我了解到有两种方法，第一种是使用秘钥进行进行传输，还有一种就是我使用的账号密码进行传输。 别忘记保存，应用。 然后我们回到我们的项目配置，进行构建后操作配置 构建后操作配置 5月30日补充：最后一步替换后执行操作，使用.代替是不对的，不执行可以不写。 别忘记保存，应用。 然后我们回到项目首页 Build Now 就可以了，完成后就会自动打包进行服务器更新了。]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向绑定]]></title>
    <url>%2F2019%2F03%2F12%2F2019-3-12-proxy%2F</url>
    <content type="text"><![CDATA[最简单的双向数据绑定的实现，开始通过使用Object.defineProperty()，到ES6新增的Proxy的实现。 HTML1234&lt;div id="app"&gt; &lt;input type="text" id="inputTxt"&gt; &lt;input type="text" id="showTxt"&gt;&lt;/div&gt; Object.defineProperty()12345678910111213var obj = &#123;&#125;;Object.defineProperty(obj, 'txt', &#123; get: function () &#123; return obj; &#125;, set: function (newValue) &#123; document.getElementById('inputTxt').value = newValue; document.getElementById('showTxt').value = newValue; &#125;&#125;)document.addEventListener('keydown', function (e) &#123; obj.txt = e.target.value;&#125;) Proxy12345678910111213141516const obj = &#123;&#125;;const aProxy = new Proxy(obj, &#123; get: function(target, key, receiver)&#123; return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; if(key === 'txt' &amp;&amp; value !== undefined) &#123; document.getElementById('inputTxt').value = value; document.getElementById('showTxt').value = value; &#125; return Reflect.set(target, key, value, receiver); &#125;&#125;);document.addEventListener('keydown', function (e) &#123; aProxy.txt = e.target.value;&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Object.defineProperty()</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包与继承]]></title>
    <url>%2F2019%2F03%2F04%2F2019-3-4-inherit%2F</url>
    <content type="text"><![CDATA[闭包与继承组合学习，加深记忆。 闭包通过一个函数，能够访问另一个函数作用域的变量的函数 123456789101112131415161718function init() &#123; var name = "Mozilla"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName();&#125;init();//Mozillafunction a(x) &#123; var y = 4; function b() &#123; console.log(x+y) &#125; return b&#125;var c = a(3)c() // 7 构造函数继承call apply方式 构造函数绑定12345678910function Animal() &#123; this.species = '动物'&#125;function Cat(name, color) &#123; Animal.apply(this, arguments) this.name = name this.color = color&#125;var cat1 = new Cat('大俊', '黑色')console.log(cat1.species) //动物 使用call和apply借用其他构造函数的成员, 可以解决给父构造函数传递参数的问题, 但是获取不到父构造函数原型上的成员.也不存在共享问题. prototype模式1234567891011function Animal() &#123; this.species = '动物'&#125;function Cat(name, color) &#123; this.name = name this.color = color&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Catvar cat1 = new Cat('大俊', '黑色')console.log(cat1.species) //动物 问题是不能给父构造函数传递参数, 父子构造函数的原型对象之间有共享问题. 直接继承prototype1234567891011function Animal() &#123;&#125;Animal.prototype.species = '动物'function Cat(name, color) &#123; this.name = name this.color = color&#125;Cat.prototype = Animal.prototypeCat.prototype.constructor = Catvar cat1 = new Cat('大俊', '黑色')console.log(cat1.species) //动物console.log(Animal.prototype.constructor) //Cat 缺点是 Cat.prototype和Animal.prototype,现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。只能继承父构造函数的原型对象上的成员, 不能继承父构造函数的实例对象的成员, 同时父构造函数的原型对象和子构造函数的原型对象上的成员有共享问题 利用空对象作为中介12345678910111213141516171819202122232425function Animal() &#123;&#125;Animal.prototype.species = '动物'function Cat(name, color) &#123; this.name = name this.color = color&#125;var F = function () &#123;&#125;F.prototype = Animal.prototypeCat.prototype = new F()Cat.prototype.constructor = Catvar cat1 = new Cat('大俊', '黑色')console.log(cat1.species)//动物//封装function extend(Child, Parent) &#123; var F = function () &#123;&#125; F.prototype = Parent.prototype Child.prototype = new F() Child.prototype.constructor = Child Child.uber = Parent.prototype//为子对象设一个uber属性， // 这个属性直接指向父对象的prototype属性为了实现继承的完备性，纯属备用性质。&#125;//使用extend(Cat, Animal)var cat1 = new Cat('大俊', '黑色')console.log(cat1.species)//动物 拷贝继承1234567891011121314151617function Animal() &#123;&#125;Animal.prototype.species = '动物'function Cat(name, color) &#123; this.name = name this.color = color&#125;function extend2(Child, Parent)&#123; var p = Parent.prototype var c = Child.prototype for(var x in p)&#123; c[x] = p[x] &#125; c.uber = p&#125;extend2(Cat, Animal)var cat1 = new Cat()console.log(cat1.species) 拷贝继承的问题,如果继承过来的成员是引用类型的话,那么这个引用类型的成员在父对象和子对象之间是共享的,也就是说修改了之后, 父子对象都会受到影响. 非构造函数继承object()方法1234567891011var Animal = &#123; species: "动物"&#125;function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var Cat = object(Animal);Cat.name = "大俊";console.log(Cat.species)//动物 浅拷贝1234567891011121314151617181920212223242526272829303132var Animal = &#123; species: "动物"&#125;function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; return c;&#125;var Cat = extendCopy(Animal);Cat.name = "大俊";console.log(Cat)//动物这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。var Animal = &#123; species: "动物"&#125;function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; return c;&#125;Animal.do = ["吃", "喝"];var Cat = extendCopy(Animal);Cat.do.push("睡觉");console.log(Cat.do)//["吃", "喝", "睡觉"]console.log(Animal.do)//["吃", "喝", "睡觉"] 3、深拷贝深拷贝，就是能够实现真正意义上的数组和对象的拷贝。递归调用”浅拷贝”就行了。 1234567891011121314151617181920var Animal = &#123; species: "动物"&#125;function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125;Animal.do = ["吃", "喝"];var Cat = deepCopy(Animal);Cat.do.push("睡觉");console.log(Cat.do)//["吃", "喝", "睡觉"]console.log(Animal.do)//["吃", "喝"] 学习地址http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断数据类型]]></title>
    <url>%2F2019%2F02%2F25%2F2019-2-25-typeof%2F</url>
    <content type="text"><![CDATA[判断类型、构造函数、对象属性等，记录到一起，方便记忆学习。 typeof操作符返回一个字符串，表示未经计算的操作数的类型，其实就是判断参数是什么类型的实例。 一般返回以下几种结果：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”。 123456789101112131415161718192021console.log(typeof 123) //numberconsole.log(typeof (1+2)) //numberconsole.log(typeof NaN) //numberconsole.log(typeof Number(6)) //numberconsole.log(typeof Infinity) //numberconsole.log(typeof "") //stringconsole.log(typeof "zyw") //stringconsole.log(typeof (typeof "zyw")) //stringconsole.log(typeof true) //booleanconsole.log(typeof false) //boolean console.log(typeof &#123;name:'zyw'&#125;) //objectconsole.log(typeof ['z', 'y', 'w']) //objectconsole.log(typeof new Date()) //objectconsole.log(typeof function()&#123;&#125;) //functionconsole.log(typeof undefined) //undefinedconsole.log(typeof zyw) //undefined zyw未定义 instanceof用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 注意上面数组和对象返回的都是object，这时就需要使用instanceof来判断了。123456789101112131415161718192021222324console.log(['z', 'y', 'w'] instanceof Array) //true// 定义构造函数function C()&#123;&#125; function D()&#123;&#125; var o = new C();o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototypeo instanceof D; // false，因为 D.prototype不在o的原型链上o instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回trueC.prototype instanceof Object // true,同上console.log("zyw" instanceof String) //falseconsole.log(new String() instanceof String) //trueconsole.log(new String("zyw") instanceof String) //trueconsole.log(new Date() instanceof String) //falseconsole.log(new String("zyw") instanceof Object) //trueconsole.log(&#123;&#125; instanceof Object) //trueconsole.log(Object.create(null) instanceof Object) //falseconsole.log(new Date() instanceof Date) //trueconsole.log(new String() instanceof Date) //falseconsole.log(new Date() instanceof Object) //true hasOwnProperty返回一个布尔值，指示对象自身属性中是否具有指定的属性 123456789o = new Object();o.prop = 'exists';function changeO() &#123; o.newprop = o.prop; delete o.prop;&#125;o.hasOwnProperty('prop'); // 返回 truechangeO();o.hasOwnProperty('prop'); // 返回 false Object.prototype.toString.call()常用于判断浏览器内置对象。 1234567console.log( Object.prototype.toString.call('zyw')) //[object String]console.log( Object.prototype.toString.call(123)) //[object Number]console.log( Object.prototype.toString.call(Symbol(123))) //[object Symbol]console.log( Object.prototype.toString.call(null)) //[object Null]console.log( Object.prototype.toString.call(undefined)) //[object Undefined]console.log( Object.prototype.toString.call(function () &#123;&#125;)) //[object Function]console.log( Object.prototype.toString.call(&#123;name: 'zyw'&#125;)) //[object Object] Array.isArray()用来判断对象是否为数组 1234var arr = ['z', 'y', 'w']console.log(Array.isArray(arr))//truevar obj = &#123;name: 'zyw'&#125;console.log(Array.isArray(obj))//false 参考网址：MDN]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>typeof</tag>
        <tag>instanceof</tag>
        <tag>hasOwnProperty</tag>
        <tag>Object.prototype.toString.call()</tag>
        <tag>isArray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blob兼容性问题]]></title>
    <url>%2F2018%2F12%2F26%2FtoBlob%2F</url>
    <content type="text"><![CDATA[接上一篇文章，图片在谷歌浏览器上使用的时候没有问题，但是在手机上测试的时候就卡在那不动了，然后我测试了安卓我们的app和手机自带浏览器都不行，又测试了苹果我们的app不行，微信和safari是可以的。 然后我就和我们的安卓小哥说让他帮我看看log,结果发现canvas.toBlob is undefined。 原因：blog方法兼容性不是很好，所以需要兼容一下解决办法：发现了这个网址解决了问题https://github.com/blueimp/JavaScript-Canvas-to-Blob;使用方法很简单，只需要把canvas-to-blob.js或者canvas-to-blob.min.js在之前引入就好了。然后下面原来的方法该怎么用就怎么用，就没有问题了。 12345678var canvas = document.createElement('canvas');if (canvas.toBlob) &#123; canvas.toBlob(function (blob) &#123; //do something &#125;, 'image/jpeg' );&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>blob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单图片上传pro(带压缩版)]]></title>
    <url>%2F2018%2F12%2F11%2Fimguploadpro%2F</url>
    <content type="text"><![CDATA[单图片做完之后发现手机拍照照片都很大，基本都在4、5M，上传速度有些慢，然后就寻找方法，开始想使用图片转base64给后台，但是发现后台不支持base64,然后寻求他路，发现给以把图片转换成canvas进行压缩。 代码如下（还是需要依赖jq） html1234567891011121314151617181920212223242526&lt;div class="imgUpload"&gt; &lt;input type="file" accept="image/*" capture="camera" class="imgUploadIpt"&gt; &lt;img src="1.png" alt=""&gt;&lt;/div&gt;``` css``` bash.imgUpload &#123; width: 88px; height: 88px; position: relative;&#125;.imgUpload input[type='file'] &#123; width: 100%; height: 100%; opacity: 0; position: absolute; z-index: 2;&#125;.imgUpload img &#123; width: 100%; height: 100%; position: absolute; z-index: 1;&#125; js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495function ImgUpload(ele, files, options ) &#123; this.ele = ele;//点击的input元素 this.files = files;//图片file this.compression = options.compression || false;//是否开启压缩默认否 this.maxWidth = options.maxWidth || 800;//压缩最大宽度 this.maxHeight = options.maxHeight || 800;//压缩最大高度 this.callback = options.callback;//回调 this.init();&#125;ImgUpload.prototype = &#123; init: function () &#123; this.onChangeUploadFile(); &#125;, onChangeUploadFile: function () &#123; var _this = this; //判断文件是否添加进来 if (this.files.length == 0) &#123; return false; &#125; var file = this.files[0]; //判断上传的是不是图片 if (file.type.indexOf('image') === -1) &#123; alert("您上传的不是图片！"); return false; &#125; //上传图片进行最大限制 var filesize = Math.floor((file.size) / 1024); if (filesize &gt; 1024 * 20) &#123; alert("上传大小不能超过20M."); return false; &#125; this.ele.parent().find("img").attr("src", window.URL.createObjectURL(file)); if( !this.compression ) &#123; if (this.callback) &#123; this.callback( file ); &#125; &#125;else &#123; // 压缩图片需要的一些元素和对象 var reader = new FileReader(), img = new Image(); //result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容 reader.readAsDataURL(file); // 文件base64化，以便获知图片原始尺寸 reader.onload = function(e) &#123; img.src = e.target.result; &#125;; // 缩放图片需要的canvas var canvas = document.createElement('canvas'); var context = canvas.getContext('2d'); img.onload = function () &#123; // 图片原始尺寸 var originWidth = this.width; var originHeight = this.height; // 最大尺寸限制 var maxWidth = _this.maxWidth, maxHeight = _this.maxHeight; // 目标尺寸 var targetWidth = originWidth, targetHeight = originHeight; // 图片尺寸超过限制 if (originWidth &gt; maxWidth || originHeight &gt; maxHeight) &#123; if (originWidth / originHeight &gt; maxWidth / maxHeight) &#123; // 更宽，按照宽度限定尺寸 targetWidth = maxWidth; targetHeight = Math.round(maxWidth * (originHeight / originWidth)); &#125; else &#123; targetHeight = maxHeight; targetWidth = Math.round(maxHeight * (originWidth / originHeight)); &#125; &#125; // canvas对图片进行缩放 canvas.width = targetWidth; canvas.height = targetHeight; // 清除画布 context.clearRect(0, 0, targetWidth, targetHeight); // 图片压缩 context.drawImage(img, 0, 0, targetWidth, targetHeight); // canvas转为blob返回 canvas.toBlob(function (blob) &#123; if (_this.callback) &#123; _this.callback( blob ); &#125; &#125;, file.type || 'image/png'); &#125;; &#125; &#125;&#125;$('.imgUploadIpt').on('change', function (event) &#123; new ImgUpload($(this), event.target.files, &#123; compression: true, //开启压缩默认不压缩 maxWidth: 600, //开启压缩图片最大宽度 maxHeight: 600, //开启压缩图片最大高度 callback:function (file) &#123;//回调函数 console.log(file); &#125; &#125;)&#125;) 具体效果点击这里; 参考地址https://www.zhangxinxu.com/wordpress/2017/07/html5-canvas-image-compress-upload/;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>imgUploadPro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntersectionObserver API]]></title>
    <url>%2F2018%2F12%2F03%2FIntersectionObserver%2F</url>
    <content type="text"><![CDATA[原来判断一个元素是否在页面显示区域中，需要使用scroll事件进行监听判断，现在有了IntersectionObserver就方便了很多。 用法为 var io = new IntersectionObserver(callback, option); IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。 // 开始观察 io.observe(document.getElementById('example')); // 停止观察 io.unobserve(element); // 关闭观察器 io.disconnect(); var io = new IntersectionObserver( entries =&gt; { entries.forEach(i =&gt; { console.log('Time: ' + i.time); console.log('Target: ' + i.target); console.log('IntersectionRatio: ' + i.intersectionRatio); console.log('rootBounds: ' + i.rootBounds); console.log(i.boundingClientRect); console.log(i.intersectionRect); console.log('================'); }); }, { /* Using default options. Details below */ } ); // Start observing an element // 多次调用 io.observe(document.querySelector('#a')); io.observe(document.querySelector('#b')); 返回的属性如下 time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target：被观察的目标元素，是一个 DOM 节点对象 rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null boundingClientRect：目标元素的矩形区域的信息 intersectionRect：目标元素与视口（或根元素）的交叉区域的信息 intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0 这里面返回的值里面有位置信息，就可以搞事情了。 看一下兼容性 虽然兼容还不是很好，要是这个方法主流兼容了就很好了。以后一定是一个好方法。 想要学习更多的请借一步前往阮大大这里看 http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>IntersectionObserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter Android Studio配置错误]]></title>
    <url>%2F2018%2F11%2F30%2Fflutter%2F</url>
    <content type="text"><![CDATA[刚开始学些flutter，安装配置的时候遇到了点小问题，配置流程我就不发了，网上很多，我的学习地址是这个，可以参考。技术胖的这篇教程;我只要是记录我在使用Android Studio运行flutter的时候出现的问题。 出现问题如下图 我是没搞懂这是什么问题，然后就请教了一下我们公司做Android的大神，他来我这一看，就找到了问题。 看着两个图，文件配置的版本号为27，虚拟机的版本号为28 两个版本号没有对上，然后我把27改成28，在debug一下就跑起来了。 闻道有先后，术业有专攻。 还是要多多学习。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单图片上传]]></title>
    <url>%2F2018%2F11%2F28%2Fimgupload%2F</url>
    <content type="text"><![CDATA[业务需求，移动端app需要一个单图片上传的功能，并且只允许照相，不允许从本地选取，本来想使用webUploader来做，配置好了，发现一个问题只能上传一次，在次上传，缩略图不替换（也有可能这个插件我没配置使用好，此处不做过多纠结），然后就参考写了一个。 代码如下（需要依赖jq） html123&lt;div id="imgUpload"&gt; &lt;img src="upload.png" alt=""&gt;&lt;!--upload.png为初始显示背景图--&gt;&lt;/div&gt; css12345678#imgUpload &#123; width: 88px; height: 88px;&#125;#imgUpload img &#123; width: 100%; height: 100%;&#125; js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//图片上传function ImgUpload(id, options) &#123; this.me = $(id); this.callback = options.callback; this.init();&#125;ImgUpload.prototype = &#123; init: function () &#123; this.eventClickInit(); &#125;, eventClickInit:function () &#123; var self = this; this.me.unbind().click(function() &#123; self.createImageUploadDialog(); &#125;) &#125;, onChangeUploadFile: function() &#123; var fileInput = this.fileInput; var files = fileInput.files; if (files.length == 0) &#123; return false; &#125; var file = files[0]; if (file.type.indexOf('image') === -1) &#123; alert("您上传的不是图片！"); return false; &#125; var img = window.URL.createObjectURL(file); var filename = file.name; var filesize = Math.floor((file.size) / 1024); if (filesize &gt; 1024 * 20) &#123; alert("上传大小不能超过20M."); return false; &#125; this.me.find("img").attr("src", img); this.me.find("img").attr("title", filename); if (this.callback) &#123; this.callback(files); &#125; &#125;, createImageUploadDialog: function() &#123; var fileInput = this.fileInput; if (!fileInput) &#123; fileInput = document.createElement('input'); fileInput.type = 'file'; fileInput.name = 'ime-images'; fileInput.accept = 'image/*'; fileInput.capture = 'camera';//只允许照相 fileInput.multiple = false;//不允许多选 fileInput.onchange = this.onChangeUploadFile.bind(this); this.fileInput = fileInput; &#125; fileInput.click(); &#125;&#125;//调用方法var dragImgUpload = new ImgUpload("#imgUpload",&#123; callback:function (files) &#123; var imgFile = files[0]; console.log(imgFile); //do something 调取接口进行上传等操作。 &#125;&#125;); 具体效果点击这里;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>imgUpload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[radio、checkbox 自定义样式]]></title>
    <url>%2F2018%2F11%2F16%2FradioCheckbox%2F</url>
    <content type="text"><![CDATA[默认的radio、checkbox的样式比较单一，往往达不到我们想要的效果，所以需要自定义我们需要的样子。 先来看一下最终效果图吧。 基础布局如下 123456789101112131415161718192021222324252627282930313233343536&lt;div class="radioBox"&gt; &lt;label&gt; &lt;input class="radioInput" type="radio" name="single" value="5"&gt; &lt;span class="radioSpan"&gt;&lt;/span&gt;5 &lt;/label&gt; &lt;label&gt; &lt;input class="radioInput" type="radio" name="single" value="4"&gt; &lt;span class="radioSpan"&gt;&lt;/span&gt;4 &lt;/label&gt; &lt;label&gt; &lt;input class="radioInput" type="radio" name="single" value="3"&gt; &lt;span class="radioSpan"&gt;&lt;/span&gt;3 &lt;/label&gt; &lt;label&gt; &lt;input class="radioInput" type="radio" name="single" value="2"&gt; &lt;span class="radioSpan"&gt;&lt;/span&gt;2 &lt;/label&gt; &lt;label&gt; &lt;input class="radioInput" type="radio" name="single" value="1"&gt; &lt;span class="radioSpan"&gt;&lt;/span&gt;1 &lt;/label&gt;&lt;/div&gt;&lt;div class="checkBox"&gt; &lt;label&gt; &lt;input class="checkInput" type="checkbox"&gt; &lt;span class="checkSpan"&gt;&lt;/span&gt;喜欢 &lt;/label&gt; &lt;label&gt; &lt;input class="checkInput" type="checkbox"&gt; &lt;span class="checkSpan"&gt;&lt;/span&gt;好看 &lt;/label&gt; &lt;label&gt; &lt;input class="checkInput" type="checkbox"&gt; &lt;span class="checkSpan"&gt;&lt;/span&gt;耐用 &lt;/label&gt;&lt;/div&gt; 样式是这样的 然后我们把我们想要的样式赋予我们添加的span标签,添加css样式。 123456789101112131415161718192021222324252627282930313233343536373839404142.radioSpan &#123; background-color:transparent; border: 1px solid #B5B5B5; border-radius:100%; display:inline-block; width:13px; height:13px; vertical-align:middle; line-height:0; margin-right: 5px;&#125;.radioInput:checked + .radioSpan &#123; border: 1px solid #16A096;&#125;.radioInput:checked + .radioSpan:after &#123; background-color:#16A096; border-radius:100%; content:""; display:inline-block; height:9px; margin:2px; width:9px;&#125;.checkSpan &#123; background-color:transparent; border: 1px solid #B5B5B5; display:inline-block; width:13px; height:13px; vertical-align:middle; line-height:0; margin-right: 5px;&#125;.checkInput:checked + .checkSpan &#123; width: 15px; height: 15px; background: url('checkedSelect.png') no-repeat center center; background-size: 15px 15px; border: none;&#125; 然后在看一下样式 然后我们在把原来的input标签隐藏就好了123456.radioInput &#123; display: none;&#125;.checkInput &#123; display: none;&#125; 这样就可以看到开始的效果了。 这里样式全部是分开写的，方便理解。。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>radio</tag>
        <tag>checkbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var() and mask]]></title>
    <url>%2F2018%2F10%2F19%2Fcssstudy%2F</url>
    <content type="text"><![CDATA[空闲时间看到俩CSS，var()、mask 没遇到过，比较好奇，学习一下。 CSS变量var()语法上来先看看是怎么写的，我就是被这惊奇的写法吸引到了。 See the Pen var() by 周艳伟 (@zywkuo) on CodePen. var 哇 css怎么用到了var，什么鬼。 原来这是css原生的变量，CSS中原生的变量定义语法是：–，变量使用语法是：var(–)，其中*表示我们的变量名称。关于命名这个东西，各种语言都有些显示，例如CSS选择器不能是数字开头，JS中的变量是不能直接数值的，但是，在CSS变量中，这些限制通通没有 但是，不能包含$，[，^，(，%等字符，普通字符局限在只要是“数字[0-9]”“字母[a-zA-Z]”“下划线_”和“短横线-”这些组合，但是可以是中文，日文或者韩文。 看一下兼容性 我们广大的猿友们，努努力吧IE干掉吧。 有想了解更多的，请来张鑫旭，张大大空间，看看他的这篇文章https://www.zhangxinxu.com/wordpress/2016/11/css-css3-variables-var/ 声明一下，上面和下面一点关系都没有，只是同时看到了，就一起学习一下。 mask遮罩mask的功能就是使用透明的图片或渐变遮罩元素的背景.我用我的大白话理解一下，就是把图片的透明处变为不透明，不透明的地方变成透明。（如有错误，欢迎指正。）所以jpg的还是就算了吧，放了也是全透明，没什么效果，开始我放了jpg的，找了半天原因。 遮罩mask是一个复合属性 mask-image mask-mode mask-repeat mask-position mask-clip mask-origin mask-size mask-type mask-composite mask-image默认值为none，值为透明图片，或透明渐变mask-image遮罩所支持的图片类型非常的广泛，可以是url()静态图片资源，格式包括JPG，PNG以及SVG等都是支持的；也可以是动态生成的图片，例如使用各种CSS3渐变绘制的图片。语法上支持CSS3各类渐变，以及url()功能符，image()功能符，甚至element()功能符。同时还支持多背景，因此理论上，使用mask-image我们可以遮罩出任意我们想要的图形，非常强大。 html &lt;img src="1.jpg" alt="" class="mask"&gt; 1.jpg图片是这个 放上这段css .mask { width: 600px; -webkit-mask-image: url(3.svg); mask-image: url(3.svg); } 3.svg长这样 运行结果这样 mask-repeatmask-repeat属性的默认值是repeat，行为类似于background-repeat属性。 属性 mask-repeat: repeat-x; //水平x平铺 mask-repeat: repeat-y; //垂直y平铺。 mask-repeat: repeat; //默认值，水平和垂直平铺。 mask-repeat: no-repeat; //不平铺 mask-repeat: space; //表示遮罩图片尽可能的平铺同时不发生任何剪裁。 mask-repeat: round; //表示遮罩图片尽可能靠在一起没有任何间隙，同时不发生任何剪裁。 mask-positionmask-position和background-position支持的属性值和表现基本上都是一模一样的。例如,mask-position默认计算值是0% 0%，也就是相对左上角定位。 支持单个关键字（缺省关键字的解析为center）： mask-position: top; mask-position: bottom; mask-position: left; mask-position: right; mask-position: center; 支持垂直和水平方向两个关键字： mask-position: right top; 支持各类数值： mask-position: 30% 50%;&lt; mask-position: 10px 5rem; 由于mask-image支持多遮罩图片，因此，mask-position也支持多属性值，例如： mask-position: 0 0, center; 这个我就不具体上图片了，想必大家都懂了。想看的请跳到张大大这里看一下吧，https://www.zhangxinxu.com/study/201711/mask-position-png.html mask-clipmask-clip属性性质上和background-clip类似，但是mask-clip支持的属性值要多一点，主要是多了个SVG元素的mask-clip支持。 属性值 mask-clip: content-box; mask-clip: padding-box; mask-clip: border-box; mask-clip: fill-box; mask-clip: stroke-box; mask-clip: view-box; mask-clip: no-clip; 其中默认值是border-box和background-clip类似。同样也支持多属性值： mask-clip: content-box, border-box; 谷歌测试了一下，全员out！！！！！！晕火狐也全员out，什么鬼，难道和笔记本有关（我的是mac）..这个还有待测试。 mask-origin属性值 mask-origin: content-box; mask-origin: padding-box; mask-origin: border-box; mask-origin: fill-box; mask-origin: stroke-box; mask-origin: view-box; 其中默认值是border-box和background-origin类似。同样也支持多属性值： mask-origin: content-box, border-box; 测试结果依旧全员out!!!!!! mask-sizemask-size属性性质上和background-size类似，支持的属性值也类似，作用是控制遮罩图片尺寸。 默认值是auto. 属性值 mask-size: cover; mask-size: contain; 支持各类数值（缺省高度会自动计算为auto）： mask-size: 50%; mask-size: 3em; mask-size: 12px; mask-size: 50% auto; mask-size: 3em 25%; mask-size: auto 6px; 同样支持多属性值： mask-size: 50%, 25%, 25%; mask-size: 6px, auto, contain; mask-typemask-type属性功能上和mask-mode类似，都是设置不同的遮罩模式。但还是有个很大的区别，那就是mask-type只能作用在SVG元素上，本质上是由SVG属性演变而来，因此，Chrome等浏览器都是支持的。但是mask-mode是一个针对所有元素的CSS3属性，Chrome等浏览器并不支持，目前仅Firefox浏览器支持。 由于只能作用在SVG元素上，因此默认值表现为SVG元素默认遮罩模式，也就是默认值是luminance，亮度遮罩模式。如果需要支持透明度遮罩模式，可以这么设置： mask-type: alpha; mask-compositemask-composite表示当同时使用多个图片进行遮罩时候的混合方式 属性值 mask-composite: add; //遮罩累加。 mask-composite: subtract; //遮罩相减。也就是遮罩图片重合的地方不显示。意味着遮罩图片越多，遮罩区域越小。 mask-composite: intersect; //遮罩相交。也就是遮罩图片重合的地方才显示遮罩。 mask-composite: exclude; //遮罩排除。也就是后面遮罩图片重合的地方排除，当作透明处理。 这个属性浏览器支持也不是很好。。。 mask-mode默认值为match-source，意思是根据资源的类型自动采用合适的遮罩模式。 mask-mode支持下面3个属性值： .mask { mask-mode: alpha; mask-mode: luminance; mask-mode: match-source; } 因为mask-image支持多图片，因此mask-mode也支持多属性值，例如： mask-mode: alpha, match-source; 这个属性浏览器支持效果还不是很好。 看一下浏览器兼容性吧。 虽然支持还不是很好，但是好东西不怕晚，欢迎指正。 学习的是张鑫旭，张大大的这篇文章https://www.zhangxinxu.com/wordpress/2016/11/css-css3-variables-var/]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>var</tag>
        <tag>mask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 网格布局(Grid Layout)]]></title>
    <url>%2F2018%2F10%2F17%2Fgrid%2F</url>
    <content type="text"><![CDATA[CSS 网格布局(Grid Layout) 是CSS中最强大的布局系统。 这是一个二维系统，这意味着它可以同时处理列和行，不像 flexbox 那样主要是一维系统。 你可以通过将CSS规则应用于父元素（成为网格容器）和该元素的子元素（网格元素），来使用网格布局。 引言CSS网格布局（又名“网格”）是一个二维的基于网格的布局系统，其目的只在于完全改变我们设计基于网格的用户界面的方式。 CSS一直用来布局网页，但一直都不完美。 一开始我们使用table 做布局，然后转向浮动、定位以及inline-block，但所有这些方法本质上都是 Hack 的方式，并且遗漏了很多重要的功能（例如垂直居中）。 Flexbox的出现在一定程度上解决了这个问题，但是它的目的是为了更简单的一维布局，而不是复杂的二维布局（Flexbox和Grid实际上一起工作得很好）。 只要我们一直在制作网站，我们就一直在为解决布局问题不断探索，而Grid是第一个专门为解决布局问题而生的CSS模块。 有两个东西，启发我写这篇指南。 第一个是雷切尔·安德鲁（Rachel Andrew）的书为CSS Grid布局准备。 这本书对网格布局做了彻底、清晰的介绍，也是是整篇文章的基础，我强烈建议你购买并阅读他的书。 我的另一个重要灵感是Chris Coyier的Flexbox完全指南，当需要查阅 flexbox 的一切资料时我就会找这篇文章。 这篇文章帮助了很多人学习 Flex 布局，也是 Google 上搜索“flexbox”关键字排名第一的文章。你会发现他的文章和我的很多相似之处，有最好的范例在那放着为什么咱不偷师学着写呢？ 本指南的目的是介绍网格概念，因为它们存在于最新版本的规范中。 因此我不会覆盖过时的IE语法，而且随着规范的成熟，我会尽最大努力保存更新本指南。 基础知识以及浏览器支持情况一开始你需要使用display：grid把容器元素定义为一个网格，使用grid-template-columns和grid-template-rows设置列和行大小，然后使用grid-column 和 grid-row把它的子元素放入网格。 与flexbox类似，网格子元素的原始顺序不重要。 你的可以在 CSS 里以任意顺序放置它们，这使得使用媒体查询重新排列网格变得非常容易。 想象一下，我们需要定义整个页面的布局，然后为了适应不同的屏幕宽度完全重新排列，我们只需要几行CSS就能实现这个需求。 网格是有史以来最强大的CSS模块之一。 截至2017年3月，许多浏览器都提供了原生的、不加前缀的对CSS Grid的支持，比如 Chrome（包括Android），Firefox，Safari（包括iOS）和Opera。 另一方面，Internet Explorer 10和11支持它，但需要使用过时的语法。 Edge浏览器已经宣布将支持标准的Grid语法，但暂未支持。 浏览器支持的详细数据可在Caniuse查看。其中里面的数字表示该版本以上的浏览器支持Grid。 桌面浏览器Chrome Opera Firefox IE Edge Safari 57 44 52 11* 16 10.1 移动端 / 平板iOS Safari Opera Mobile Opera Mini Android Android Chrome Android Firefox 10.3 No No 62 62 57 除了微软之外，浏览器制造商在 Grid 规范完全落地以前似乎并没有放手让 Gird 野生也长的打算。 这是一件好事，这意味着我们不需要再去学习各种浏览器兼容版本的旧语法。 在生产环境中使用Grid只是时间问题，但现在是我们该学习的时候了。 重要术语在深入了解网格的概念之前，理解术语是很重要的。 由于这里所涉及的术语在概念上都是相似的，如果不先记住它们在网格规范中定义的含义，则很容易将它们彼此混淆。 但是不用太担心，这些术语并不多。 Grid Container设置了 display: gird 的元素。 这是所有 grid item 的直接父项。 在下面的例子中，.container 就是是 grid container。 &lt;div class="container"&gt; &lt;div class="item item-1"&gt;&lt;/div&gt; &lt;div class="item item-2"&gt;&lt;/div&gt; &lt;div class="item item-3"&gt;&lt;/div&gt; &lt;/div&gt; Grid ItemGrid 容器的孩子（直接子元素）。下面的 .item 元素就是 grid item，但 .sub-item不是。 &lt;div class="container"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt; &lt;p class="sub-item"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;/div&gt; Grid Line这个分界线组成网格结构。 它们既可以是垂直的（“column grid lines”），也可以是水平的（“row grid lines”），并位于行或列的任一侧。 下面例中的黄线就是一个列网格线。 Grid Track两个相邻网格线之间的空间。 你可以把它们想象成网格的列或行。 下面是第二行和第三行网格线之间的网格轨道。 Grid Cell两个相邻的行和两个相邻的列网格线之间的空间。它是网格的一个“单元”。 下面是行网格线1和2之间以及列网格线2和3的网格单元。 Grid Area四个网格线包围的总空间。 网格区域可以由任意数量的网格单元组成。 下面是行网格线1和3以及列网格线1和3之间的网格区域。 Grid 属性列表Grid Container 的全部属性 display grid-template-columns grid-template-rows grid-template-areas grid-template grid-column-gap grid-row-gap grid-gap justify-items align-items justify-content align-content grid-auto-columns grid-auto-rows grid-auto-flow grid Grid Items 的全部属性 grid-column-start grid-column-end grid-row-start grid-row-end grid-column grid-row grid-area justify-self align-self 父容器(Grid Container)的属性display将元素定义为 grid contaienr，并为其内容建立新的网格格式化上下文(grid formatting context)。 值:grid – 生成一个块级(block-level)网格(主要的还是使用这个属性,想要使用grid,就要先设置这个值)inline-grid – 生成一个行级(inline-level)网格subgrid – 如果你的 grid container 本身就是一个 grid item（即,嵌套网格），你可以使用这个属性来表示你想从它的父节点获取它的行/列的大小，而不是指定它自己的大小。 .container { display: grid | inline-grid | subgrid; } 注意：column, float, clear, 以及 vertical-align 对一个 grid container 没有影响 grid-template-columns / grid-template-rows使用以空格分隔的多个值来定义网格的列和行。这些值表示轨道大小(track size)，它们之间的空格代表表格线(grid line)。 .container { grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...; grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...; } 例子:(如果未显示的给网格线命名)，轨道值之间仅仅有空格时，网格线会被自动分配数字名称： .container { grid-template-columns: 40px 50px auto 50px 40px; grid-template-rows: 25% 100px auto; } 但你可以给网格线指定确切的命名。 注意中括号里的网格线命名语法： .container { grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end]; grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line]; } 需要注意的是，一个网格线可以有不止一个名字。例如，这里第2条网格线有两个名字：row1-end 和 row2-start： .container { grid-template-rows: [row1-start] 25% [row1-end row2-start] 25% [row2-end]; } 如果你的定义中包含重复的部分，则可以使用repeat() 符号来简化写法： .container { grid-template-columns: repeat(3, 20px [col-start]) 5%; } 上面的写法和下面等价： .container { grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%; } “fr”单位允许您将轨道大小设置为网格容器自由空间的一部分。 例如，下面的代码会将每个 grid item 为 grid container 宽度的三分之一： .container { grid-template-columns: 1fr 1fr 1fr; } 自由空间是在排除所有不可伸缩的 grid item 之后计算得到的。 在下面的示例中，fr单位可用的自由空间总量不包括50px: .container { grid-template-columns: 1fr 50px 1fr 1fr; } grid-template-areas通过引用 grid-area属性指定的网格区域的名称来定义网格模板。 重复网格区域的名称导致内容扩展到这些单元格。 点号表示一个空单元格。 语法本身提供了网格结构的可视化。 值： – 使用 grid-area 属性设置的网格区域的名称. – 点号代表一个空网格单元none – 没有定义网格区域举例： .item-a { grid-area: header; } .item-b { grid-area: main; } .item-c { grid-area: sidebar; } .item-d { grid-area: footer; } .container { grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: "header header header header" "main main . sidebar" "footer footer footer footer"; } 这将创建一个四列宽三行高的网格。 整个第一行将由 header 区域组成。 中间一行将由两个 main 区域、一个空单元格和一个 sidebar 区域组成。 最后一行是footer区域组成。你的声明中的每一行都需要有相同数量的单元格。 您可以使用任意数量的相邻的.来声明单个空单元格。 只要这些点号之间没有空格，他们就代表了一个单一的单元格。 需要注意的是你不是在用这个语法命名网格线，而是在命名区域。 当你使用这种语法时，区域两端的网格线实际上是自动命名的。 比如，如果网格区域的名称是foo，那么区域的起始的行网格线和列网格线名称是 foo-start，并且区域终点的行网格线和列网格线名称是 foo-end。 这意味着某些网格线可能有多个名称，比如上面的例子中最左边的一条网格线有三个名字：header-start，main-start 和 footer-start。 grid-template在单个声明中定义 grid-template-rows、grid-template-columns、grid-template-areas 的简写。 值： none – 将三个属性都设置为其初始值subgrid – 把 grid-template-rows 和 grid-template-columns 设置为 subgrid, 并且 grid-template-areas 设置为初始值grid-template-rows / &lt;grid-template-columns – 把 grid-template-columns 和 grid-template-rows 设置为指定值, 与此同时, 设置 grid-template-areas 为 none .container { grid-template: none | subgrid | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;; } 它也可以使用一个更复杂但相当方便的语法来指定这三个值。 一个例子： .container { grid-template: [row1-start] "header header header" 25px [row1-end] [row2-start] "footer footer footer" 25px [row2-end] / auto 50px auto; } 以上等价于： .container { grid-template-rows: [row1-start] 25px [row1-end row2-start] 25px [row2-end]; grid-template-columns: auto 50px auto; grid-template-areas: "header header header" "footer footer footer"; } 由于 grid-template 不会重置隐式网格属性（grid-auto-columns，grid-auto-rows和grid-auto-flow），而这可能是大多数情况下你想要做的。因此建议使用grid属性来代替grid-template。 grid-column-gap / grid-row-gap指定网格线的大小，你可以把它想象为设置列/行之间的间距的宽度。 值： line-size – 一个长度值 .container { grid-column-gap: &lt;line-size&gt;; grid-row-gap: &lt;line-size&gt;; } 举例： .container { grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; grid-column-gap: 10px; grid-row-gap: 15px; } 只能在列/行之间创建缝隙，而不是在外部边缘创建。 grid-gapgrid-row-gap 和 grid-column-gap 的缩写 .container { grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; } Example: .container { grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; grid-gap: 10px 15px; } 如果没有指定 grid-row-gap，则会被设置为与 grid-column-gap 相同的值。 justify-items沿着行轴对齐网格内的内容（与之对应的是 align-items, 即沿着列轴对齐），该值适用于容器内的所有的 grid items。 值： start: 内容与网格区域的左端对齐end: 内容与网格区域的右端对齐center: 内容位于网格区域的中间位置stretch: 内容宽度占据整个网格区域空间(这是默认值) .container { justify-items: start | end | center | stretch; } 举例： .container { justify-items: start; } .container{ justify-items: end; } .container { justify-items: center; } .container { justify-items: stretch; } 也可以通过给单个 grid item 设置justify-self属性来达到上述效果。 align-items沿着列轴对齐grid item 里的内容（与之对应的是使用 justify-items 设置沿着行轴对齐），该值适用于容器内的所有 grid items。 值： start: 内容与网格区域的顶端对齐end: 内容与网格区域的底部对齐center: 内容位于网格区域的垂直中心位置stretch: 内容高度占据整个网格区域空间(这是默认值) .container { align-items: start | end | center | stretch; } 举例: .container { align-items: start; } .container { align-items: end; } .container { align-items: center; } .container { align-items: stretch; } 也可以通过给单个 grid item 设置align-self属性来达到上述效果。 justify-content有时，网格的总大小可能小于其网格容器的大小。如果你的所有 grid items 都使用像px这样的非弹性单位来设置大小，则可能发生这种情况。此时，你可以设置网格容器内的网格的对齐方式。 此属性沿着行轴对齐网格（与之对应的是 align-content, 沿着列轴对齐）。 值： start – 网格与网格容器的左边对齐end – 网格与网格容器的右边对齐center – 网格与网格容器的中间对齐stretch – 调整g rid item 的大小，让宽度填充整个网格容器space-around – 在 grid item 之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半space-between – 在 grid item 之间设置均等宽度空白间隙，其外边缘无间隙space-evenly – 在每个 grid item 之间设置均等宽度的空白间隙，包括外边缘 .container { justify-content: start | end | center | stretch | space-around | space-between | space-evenly; } 举例： .container { justify-content: start; } .container { justify-content: end; } .container { justify-content: center; } .container { justify-content: stretch; } .container { justify-content: space-around; } .container { justify-content: space-between; } .container { justify-content: space-evenly; } align-content有时，网格的总大小可能小于其网格容器的大小。如果你的所有 grid items 都使用像px这样的非弹性单位来设置大小，则可能发生这种情况。此时，你可以设置网格容器内的网格的对齐方式。 此属性沿着列轴对齐网格（与之对应的是 justify-content, 即沿着行轴对齐）。 值： start – 网格与网格容器的顶部对齐end – 网格与网格容器的底部对齐center – 网格与网格容器的中间对齐stretch – 调整 grid item 的大小，让高度填充整个网格容器space-around – 在 grid item 之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半space-between – 在 grid item 之间设置均等宽度空白间隙，其外边缘无间隙space-evenly – 在每个 grid item 之间设置均等宽度的空白间隙，包括外边缘 .container { align-content: start | end | center | stretch | space-around | space-between | space-evenly; } 举例： .container { align-content: start; } .container { align-content: end; } .container { align-content: center; } .container { align-content: stretch; } .container { align-content: space-around; } .container { align-content: space-between; } .container { align-content: space-evenly; } grid-auto-columns / grid-auto-rows指定自动生成的网格轨道（又名隐式网格轨道）的大小。 隐式网格轨道在你显式的定位超出指定网格范围的行或列（使用 grid-template-rows/grid-template-columns）时被创建。 值： – 可以是一个长度值，一个百分比值，或者一个自由空间的一部分（使用 fr 单位） .container { grid-auto-columns: &lt;track-size&gt; ...; grid-auto-rows: &lt;track-size&gt; ...; } 为了说明如何创建隐式网格轨道，思考如下代码： .container { grid-template-columns: 60px 60px; grid-template-rows: 90px 90px } 这里创建了一个 2×2的网格。 但是，现在想象一下，使用 grid-column 和 grid-row 来定位你的网格项目，如下所示： .item-a { grid-column: 1 / 2; grid-row: 2 / 3; } .item-b { grid-column: 5 / 6; grid-row: 2 / 3; } 这里我们指定 .item-b开始于列网格线 5 并结束于在列网格线 6，但我们并未定义列网格线 5 或 6。因为我们引用不存在的网格线，宽度为0的隐式轨道的就会被创建用与填补间隙。我们可以使用 grid-auto-columns 和 grid-auto-rows属性来指定这些隐式轨道的宽度： .container { grid-auto-columns: 60px; } grid-auto-flow如果你存在没有显示指明放置在网格上的 grid item，则自动放置算法会自动放置这些项目。 而该属性则用于控制自动布局算法的工作方式。 值： row – 告诉自动布局算法依次填充每行，根据需要添加新行column – 告诉自动布局算法依次填充每列，根据需要添加新列dense – 告诉自动布局算法，如果后面出现较小的 grid item，则尝试在网格中填充空洞 .container { grid-auto-flow: row | column | row dense | column dense } 需要注意的是，dense 可能导致您的 grid item 乱序。 举例， 考虑如下 HTML： &lt;section class="container"&gt; &lt;div class="item-a"&gt;item-a&lt;/div&gt; &lt;div class="item-b"&gt;item-b&lt;/div&gt; &lt;div class="item-c"&gt;item-c&lt;/div&gt; &lt;div class="item-d"&gt;item-d&lt;/div&gt; &lt;div class="item-e"&gt;item-e&lt;/div&gt; &lt;/section&gt; 你定义一个有5列和2行的网格，并将 grid-auto-flow 设置为 row（这也是默认值）： .container { display: grid; grid-template-columns: 60px 60px 60px 60px 60px; grid-template-rows: 30px 30px; grid-auto-flow: row; } 当把 grid item 放在网格上时，你只把其中两个设置了固定的位置： .item-a { grid-column: 1; grid-row: 1 / 3; } .item-e { grid-column: 5; grid-row: 1 / 3; } 因为我们将 grid-auto-flow 设置为row，所以我们的grid就像这样。 注意观察我们没有做设置的三个项目（item-b，item-c和item-d）是如何在剩余的行水平摆放位置的： 如果我们将 grid-auto-flow 设置为 column，则 item-b，item-c 和 item-d 以列的顺序上下摆放： .container { display: grid; grid-template-columns: 60px 60px 60px 60px 60px; grid-template-rows: 30px 30px; grid-auto-flow: column; } grid在单个属性中设置所有以下属性的简写：grid-template-rows，grid-template-columns，grid-template-areas，grid-auto-rows，grid-auto-columns和grid-auto-flow。 它同时也将 sets grid-column-gap 和 grid-row-gap 设置为它们的初始值，即使它们不能被此属性显示设置。 值： none – 将所有子属性设置为其初始值 &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt; – 将 grid-template-rows 和 grid-template-columns 分别设置为指定值，将所有其他子属性设置为其初始值 &lt;grid-auto-flow&gt; [&lt;grid-auto-rows&gt; [ / &lt;grid-auto-columns&gt;] ] – 接受所有与grid-auto-flow，grid-auto-rows和grid-auto-columns相同的值。 如果省略grid-auto-columns，则将其设置为为grid-auto-rows指定的值。 如果两者都被省略，则它们被设置为它们的初始值 .container { grid: none | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt; | &lt;grid-auto-flow&gt; [&lt;grid-auto-rows&gt; [/ &lt;grid-auto-columns&gt;]]; } 举例： 以下代码写法等价 .container { grid: 200px auto / 1fr auto 1fr; } .container { grid-template-rows: 200px auto; grid-template-columns: 1fr auto 1fr; grid-template-areas: none; } 以下代码写法等价 .container { grid: column 1fr / auto; } .container { grid-auto-flow: column; grid-auto-rows: 1fr; grid-auto-columns: auto; } 它也可用使用一个更复杂但相当方便的语法来一次设置所有内容。 你可以指定 grid-template-areas、grid-template-rows 以及 grid-template-columns，并将所有其他子属性设置为其初始值。 你现在所做的是在其网格区域内，指定网格线名称和内联轨道大小。 可以看下面的例子： .container { grid: [row1-start] "header header header" 1fr [row1-end] [row2-start] "footer footer footer" 25px [row2-end] / auto 50px auto; } 上述代码等价于 .container { grid-template-areas: "header header header" "footer footer footer"; grid-template-rows: [row1-start] 1fr [row1-end row2-start] 25px [row2-end]; grid-template-columns: auto 50px auto; } 孩子(Grid Items)的属性grid-column-start / grid-column-end / grid-row-start /grid-row-end使用特定的网格线确定 grid item 在网格内的位置。grid-column-start/grid-row-start 属性表示grid item的网格线的起始位置，grid-column-end/grid-row-end属性表示网格项的网格线的终止位置。 值： &lt;line&gt;: 可以是一个数字来指代相应编号的网格线，也可使用名称指代相应命名的网格线 span &lt;number&gt;: 网格项将跨越指定数量的网格轨道 span &lt;name&gt;: 网格项将跨越一些轨道，直到碰到指定命名的网格线 auto: 自动布局， 或者自动跨越， 或者跨越一个默认的轨道 .item { grid-column-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-column-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-row-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-row-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto } 举例： .item-a { grid-column-start: 2; grid-column-end: five; grid-row-start: row1-start grid-row-end: 3 } .item-b { grid-column-start: 1; grid-column-end: span col4-start; grid-row-start: 2 grid-row-end: span 2 } 如果没有声明 grid-column-end / grid-row-end，默认情况下，该网格项将跨越1个轨道。 网格项可以相互重叠。 您可以使用z-index来控制它们的堆叠顺序。 grid-column / grid-rowgrid-column-start + grid-column-end, 和 grid-row-start + grid-row-end 的简写形式。 值： &lt;start-line&gt; / &lt;end-line&gt; – 每个值的用法都和属性分开写时的用法一样 .item { grid-column: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;; } 举例： .item-c { grid-column: 3 / span 2; grid-row: third-line / 4; } 如果没有指定结束行值，则该网格项默认跨越1个轨道。 grid-area给 grid item 进行命名以便于使用 grid-template-areas 属性创建模板时来进行引用。另外也可以做为 grid-row-start + grid-column-start + grid-row-end + grid-column-end 的简写形式。 值： &lt;name&gt; – 你的命名 &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt; – 可以是数字，也可以是网格线的名字 .item { grid-area: &lt;name&gt; | &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;; } 举例: 给一个网格项命名 .item-d { grid-area: header } 作为 grid-row-start + grid-column-start + grid-row-end + grid-column-end 的简写: .item-d { grid-area: 1 / col4-start / last-line / 6 } justify-self沿着行轴对齐grid item 里的内容（与之对应的是 align-self, 即沿列轴对齐）。 此属性对单个网格项内的内容生效。 值： start – 将内容对齐到网格区域的左端end – 将内容对齐到网格区域的右端center – 将内容对齐到网格区域的中间stretch – 填充网格区域的宽度 (这是默认值)举例： .item-a { justify-self: start; } .item-a { justify-self: end; } .item-a { justify-self: center; } .item-a { justify-self: stretch; } 要为网格中的所有grid items 设置对齐方式，也可以通过 justify-items 属性在网格容器上设置此行为。 align-self沿着列轴对齐grid item 里的内容（与之对应的是 justify-self, 即沿行轴对齐）。 此属性对单个网格项内的内容生效。 值： start – 将内容对齐到网格区域的顶部end – 将内容对齐到网格区域的底部center – 将内容对齐到网格区域的中间stretch – 填充网格区域的高度 (这是默认值) .item { align-self: start | end | center | stretch; } 举例: .item-a { align-self: start; } .item-a { align-self: end; } .item-a { align-self: center; } .item-a { align-self: stretch; } 要为网格中的所有grid items 统一设置对齐方式，也可以通过 align-items 属性在网格容器上设置此行为。 终于COPY完了，以上部分来自饥人谷fr 单位(等分)fr 是为网格布局定义的一个新单位。它可以帮助你摆脱计算百分比，并将可用空间等分。 例如，如果在网格容器中设置这个规则：grid-template-rows: 2fr 3fr，那么你的网格容器将首先被分成 2 行。然后将数字部分加在一起，这里总和为 5， 即 5 等分。 就是说，我们将有 2 行：第一排占据垂直空间的 2/5 。 第二排占垂直空间的 3/5 。 用fr来个有3行3列的布局怎么实现？ .container { display: grid; grid-template-rows: 1fr 1fr 1fr; grid-template-columns: 1fr 1fr 1fr; } 这里特别需要注意的是： fr 单位是等分可用空间，或者说剩余空间。看个例子 .container { grid-gap:2px; display: grid; width:300px; height:200px; grid-template-rows: 100px 1fr 1fr; grid-template-columns: 1fr 50px 1fr; } 你会看到 fr 单位是将 总的尺寸 减去 单元格明确尺寸后，在等分剩余空间。 grid-gap 是间隔。 repeat() 函数在某些情况下，我们可能有很多的列和行。在 grid-template 属性中指定每一个值可能会很乏味。幸运的是，有一个 repeat 函数，就像任何一个循环重复多少次输出某个给定值。它有两个参数。第一个是迭代次数，第二个是要重复的值。我们用 repeat 函数重写上面的例子。 .container { display: grid; grid-template-rows: repeat(3, 1fr); grid-template-columns: repeat(3, 1fr); } 等价于： .container { display: grid; grid-template-rows: 1fr 1fr 1fr; grid-template-columns: 1fr 1fr 1fr; } 参考学习网址 http://www.css88.com/archives/8675]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端跨域方案]]></title>
    <url>%2F2018%2F09%2F25%2Fproxy%2F</url>
    <content type="text"><![CDATA[做了一份关于跨域的ppt,主要讲解了，使用vue-cli、nginx、node.js进行跨域处理。欢迎下载观看。 PPT请点击这里下载 下面附上几张照片，node.js跨域源码在下面。 proxy.js var PORT = 3000; var http = require('http'); var url=require('url'); var fs=require('fs'); var mine=require('./mime').types; var path=require('path'); var httpProxy = require('http-proxy'); var proxy = httpProxy.createProxyServer({ target: 'http://192.168.2.18:8080/', //接口地址 // 下面的设置用于https // ssl: { // key: fs.readFileSync('server_decrypt.key', 'utf8'), // cert: fs.readFileSync('server.crt', 'utf8') // }, // secure: false }); proxy.on('error', function(err, req, res){ res.writeHead(500, { 'content-type': 'text/plain' }); console.log(err); res.end('Something went wrong. And we are reporting a custom error message.'); }); var server = http.createServer(function (request, response) { var pathname = url.parse(request.url).pathname; //var realPath = path.join("main-pages", pathname); // 指定根目录 var realPath = path.join("./", pathname); console.log(pathname); console.log(realPath); var ext = path.extname(realPath); ext = ext ? ext.slice(1) : 'unknown'; //判断如果是接口访问，则通过proxy转发 if(pathname.indexOf("meis") &gt; 0){ proxy.web(request, response); return; } fs.exists(realPath, function (exists) { if (!exists) { response.writeHead(404, { 'Content-Type': 'text/plain' }); response.write("This request URL " + pathname + " was not found on this server."); response.end(); } else { fs.readFile(realPath, "binary", function (err, file) { if (err) { response.writeHead(500, { 'Content-Type': 'text/plain' }); response.end(err); } else { var contentType = mine[ext] || "text/plain"; response.writeHead(200, { 'Content-Type': contentType }); response.write(file, "binary"); response.end(); } }); } }); }); server.listen(PORT); console.log("Server runing at port: " + PORT + "."); mime.js exports.types = { "css": "text/css", "gif": "image/gif", "html": "text/html", "ico": "image/x-icon", "jpeg": "image/jpeg", "jpg": "image/jpeg", "js": "text/javascript", "json": "application/json", "pdf": "application/pdf", "png": "image/png", "svg": "image/svg+xml", "swf": "application/x-shockwave-flash", "tiff": "image/tiff", "txt": "text/plain", "wav": "audio/x-wav", "wma": "audio/x-ms-wma", "wmv": "video/x-ms-wmv", "xml": "text/xml", "woff": "application/x-woff", "woff2": "application/x-woff2", "tff": "application/x-font-truetype", "otf": "application/x-font-opentype", "eot": "application/vnd.ms-fontobject" };]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>node.js</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3 + ElementUI]]></title>
    <url>%2F2018%2F09%2F03%2Fvue-cli%2F</url>
    <content type="text"><![CDATA[使用vue-cli3脚手架搭配ElementUI做了一个简单的PC后台管理系统连接地址账号密码随便输,不写也行。github源码在这里下载在下来后安装依赖，启动项目应该就可以看了。 我也在学习中，持续更新。。。。。。]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>cli3</tag>
        <tag>ElementUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rest参数(...变量名)和扩展运算符(...)]]></title>
    <url>%2F2018%2F08%2F23%2F(...)%2F</url>
    <content type="text"><![CDATA[之前写的一篇数组去重的方法，这样写的。 const array = [1,1,2,3,4,5,5,6,6,7,8,8]; function distinct(){ let arr = [].concat.apply([], arguments); console.log(arr); return Array.from(new Set(arr)); } const a = [1,2,3,5],b = [2,5,8,6],c = [7,8,9]; console.log(distinct(a,b,c));//[1, 2, 3, 5, 8, 6, 7, 9] 后来我一想，既然都用ES6了，不如都用ES6语法吧。然后我就把代码改成这样了。 distinct = () =&gt; { let arr = [].concat.apply([], arguments); return Array.from(new Set(arr)); } console.log(distinct(array));//Uncaught ReferenceError: arguments is not defined 报错了，让后查找了一下原因，使用为箭头函数没有arguments，怎么办，这就需要用rest参数了。 const a = [1,2,3,5],b = [2,5,8,6],c = [7,8,9]; distinct = (...theArgs) =&gt; { let arr = [].concat.apply([], theArgs); return Array.from(new Set(arr)); } console.log(distinct(a,b,c));//[1, 2, 3, 5, 8, 6, 7, 9] 这个...theArgs就是rest参数了，theArgs是自定义的命名，可以随便起名字。 rest参数(…变量名)最主要用于不定参数，用于获取函数多余的参数，将多余的逗号分隔的参数序列转换为数组参数 rest参数的语法 function f(a, b, ...theArgs) { // ... } 看一个小例子 fun1 = (...theArgs) =&gt; { console.log(theArgs); } fun1(1, 2, 3, 4, 5, 6);//[1, 2, 3, 4, 5, 6] fun2 = (a, b, ...theArgs) =&gt; { console.log(theArgs);//[3, 4, 5, 6] } fun2(1, 2, 3, 4, 5, 6); 注意：rest参数只能是最后一个参数，他代表除a,b以外的所有参数，如果后面在添加别参数，例如 fun2 = (a, b, ...theArgs, c) =&gt; { console.log(theArgs); } fun2(1, 2, 3, 4, 5, 6);Uncaught SyntaxError: Rest parameter must be last formal parameter 这样是会报错的。 说到这里这个...还有一个作用就是作为扩展运算符 扩展运算符(…)扩展运算符可以理解为rest参数的逆运算，将数组转换为逗号分隔的参数序列 const nums = [1, 2, 3]; fun = (a, b, c) =&gt; { console.log(`${a} ${b} ${c}`) } fun(...nums);//1 2 3 ES5的话我们还需要这样调用 fun.apply(null,nums); 扩展运算符应用合并数组const arr1 = [1, 2, 3] const arr2 = [5, 6] ES5 console.log(arr1.concat(arr2));//[1, 2, 3, 5, 6] ES6 console.log([...arr1, ...arr2]);//[1, 2, 3, 5, 6] 判断最大值最小值const array = [1,1,2,3,4,5,5,6,6,7,8,8]; ES5 console.log( Math.max.apply(null, array));//8 console.log( Math.min.apply(null, array));//1 ES6 console.log( Math.max(...array));//8 console.log( Math.min(...array));//1 数组去重const array = [1,1,2,3,4,5,5,6,6,7,8,8]; const distinct = arr =&gt; [...new Set(arr)]; console.log(distinct(array));//[1, 2, 3, 4, 5, 6, 7, 8]]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>rest参数</tag>
        <tag>扩展运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[position:sticky]]></title>
    <url>%2F2018%2F08%2F21%2Fsticky%2F</url>
    <content type="text"><![CDATA[css position属性的值有absolute、fixed、relative、static、inherit等，今天发现一个新的值 sticky 粘性定位，该定位基于用户滚动的位置。 这个属性比较不错，遗憾的是兼容性还不是很好，先来张图看一下 再来看一下他能干什么，比如说我一片文章有6个标题，让后读者读到每个标题对应的内容的时候让标题在顶部显示，看demo。 See the Pen YOzJoP by 周艳伟 (@zywkuo) on CodePen. 还有一些移动端页面标题固定顶部，看这个demo See the Pen sticky2 by 周艳伟 (@zywkuo) on CodePen. 这个属性值还是很不错的，用起来是不是感觉很方便，如果用js的话还需要进行判断高度在做处理相对来说还是这个简便快捷。 希望赶快普及吧！]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>position:sticky</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组去重]]></title>
    <url>%2F2018%2F08%2F10%2Fdistinct%2F</url>
    <content type="text"><![CDATA[数组去重，老生常谈，记录我觉得比较好的方法 ES5方法利用对象唯一属性进行去重var array = [1,1,2,3,4,5,5,6,6,7,8,8]; Array.prototype.distinct = function () { var array = []; var obj = {}; for(var i=0;i&lt;this.length;i++){ if(!obj[this[i]]){ array.push(this[i]); obj[this[i]] = 1; } } return array; } console.log(array.distinct());//[1, 2, 3, 4, 5, 6, 7, 8] 利用indexOf属性进行判断var array = [1,1,2,3,4,5,5,6,6,7,8,8]; Array.prototype.distinct = function () { var array = [this[0]]; for(var i=0;i&lt;this.length;i++){ if(array.indexOf(this[i]) == -1){ array.push(this[i]) } } return array; } console.log(array.distinct());//[1, 2, 3, 4, 5, 6, 7, 8] ES6方法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。利用他的唯一性就可以进行去重了。 const array = [1,1,2,3,4,5,5,6,6,7,8,8]; console.log(new Set(array));//{1, 2, 3, 4, 5, 6, 7, 8} 此时可以看到原数组已经已经去重了，但是此时结构还不是数组的结构，因此我们还需要用到Array.from方法，Array.from方法可以将 Set 结构转为数组。 const array = [1,1,2,3,4,5,5,6,6,7,8,8]; console.log(Array.from(new Set(array)));//[1, 2, 3, 4, 5, 6, 7, 8] 记录一个多个数组合并去重的好方法 function distinct(){ let arr = [].concat.apply([], arguments); console.log(arr); return Array.from(new Set(arr)); } const a = [1,2,3,5],b = [2,5,8,6],c = [7,8,9]; console.log(distinct(a,b,c));//[1, 2, 3, 5, 8, 6, 7, 9]]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js数组去重</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[:focus-within选择器]]></title>
    <url>%2F2018%2F08%2F07%2FfocusWithin%2F</url>
    <content type="text"><![CDATA[看新闻看到了一个非常不错的选择器:focus-within，他可以做一些js的效果，focus是获取焦点，所以只能有focus状态的元素才可以使用。:focus-within选择器是在元素获取焦点的时候可以触发自身或者父元素的属性（冒泡）。 举一个小例子效果如图 css .parent{ width: 100%; height: 200px; background: #eeeeee; display: flex; justify-content: center; align-items: center; } .children{ width: 100px; height: 60px; background: #999; } .parent:focus-within{ background: #f60; }&gt; html &lt;div class="parent"&gt; &lt;button class="children"&gt;点我&lt;/button&gt; &lt;/div&gt; 写了一个选项卡的小例子效果可以看一下具体代码可以点击此链接前往codepen查看，效果也有哦！ 在看一下兼容问题 数据来源于https://caniuse.com/ 虽然对浏览器的兼容效果还不是很好，希望快快普及吧。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>:focus-within</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql语句学习]]></title>
    <url>%2F2018%2F08%2F03%2Fsql%2F</url>
    <content type="text"><![CDATA[sql学习记录从 “qc_record” 表中选取所有记录 (*qc_record为一个表的名称) select * from qc_record; 一些最重要的 SQL 命令（*SQL 对大小写不敏感：SELECT 与 select 是相同的。） SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SELECT 语句SELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。 SQL SELECT 语法 select * from qc_record; 查询整个表内容 select column_name,column_name from qc_record; -- column_name(查询表内某一列名称可查询多个) SELECT DISTINCT 语句在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。 SQL SELECT DISTINCT 语法 select distinct column_name,column_name from qc_record; -- column_name(查询表内某一列名称可查询多个) WHERE 子句WHERE 子句用于提取那些满足指定标准的记录。 WHERE 语法 select * from qc_record where column_name operator value; -- 查找qc_record表中匹配column_name operator value（匹配表达式）的记录 select column_name,column_name from qc_record where column_name operator value; -- 查找qc_record表中对应名称的匹配column_name operator value（匹配表达式）的记录 SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。如果是数值字段，请不要使用引号。 WHERE 子句中的运算符 运算符 描述 = 等于 &lt;&gt; 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 != &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 后记，在查询语句的时候用到了模糊查询， LIKE 条件匹配模式 % 包含零个或更多字符的任意字符串。 _（下划线） 任何单个字符。 [ ] 指定范围（例如 [a-f]）或集合（例如 [abcdef]）内的任何单个字符。 [^] 不在指定范围（例如 [^a - f]）或集合（例如 [^abcdef]）内的任何单个字符。 AND &amp; OR 运算符AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。 AND 语法 select * from qc_record where test_user = 'zyw' and device_id = 19222; -- 与的关系，and连接的两个名称匹配都true才显示 OR 语法 select * from qc_record where test_user = 'zyw' or device_id = 19222; -- 或的关系，or连接的两个名称有一个匹配的就显示 AND OR 语法 select * from qc_record where test_user = 'zyw' and (device_id = 19121 or status = 1); -- 也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式） ORDER BY 关键字ORDER BY 关键字用于对结果集进行排序。ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。 ORDER BY 语法 select * from qc_record order by create_date desc -- ASC--&gt;升序排列默认 DESC--&gt;降序排列要写这个关键字 INSERT INTO 语句INSERT INTO 语句用于向表中插入新记录。 INSERT INTO 语法(有两种编写形式) 第一种形式无需指定要插入数据的列名，只需提供被插入的值即可： insert into qc_record values (value1,value2,value3,...); 第二种形式需要指定列名及被插入的值： insert into qc_record (column1,column2,column3,...) values (value1,value2,value3,...); UPDATE 语句UPDATE 语句用于更新表中的记录。 UPDATE 语句 update qc_record set column1=value1,column2=value2,... where some_column=some_value; -- WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！ DELETE 语句DELETE 语句用于删除表中的记录。 SQL DELETE 语法 delete from qc_record where some_column=some_value; -- 删除一条属性 delete from qc_record where some_column=some_value and some_column=some_value ...; -- 删除多条属性 delete from qc_record -- 删除所有 参考网址 SQL教程|菜鸟教程]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js模糊查询]]></title>
    <url>%2F2018%2F08%2F01%2Fsearch%2F</url>
    <content type="text"><![CDATA[对于前端而言一些简单的查询还是不用需要后台配合的，前端自己也可以处理，最简单的就是用indexof判断进行显示隐藏，下面记录一个比较不错的方法，可以支持汉字、拼音、拼音首字母大写小写。 pinyin-engine 是一个简单高效的JavaScript拼音本地匹配引擎，它支持多音字，另外提供全文版支持繁体字 点击此处进行下载 也可以点击此处进行效果预览 源代码在这里 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=yes" /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;style&gt; *{ margin: 0; padding: 0; } input{ width: 80%; height: 50px; display: block; margin: 30px auto ; background: #F0F0F0; border: 1px solid #333; font-size: 26px; text-indent: 30px; } #cityBox{ text-align: center; } &lt;/style&gt; &lt;body&gt; &lt;input type="text" id="inp"&gt; &lt;ul id="cityBox"&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script src="PinyinEngine.js"&gt;&lt;/script&gt; &lt;script&gt; var demoData = [ {name: '海门', value: 9}, {name: '鄂尔多斯', value: 12}, {name: '招远', value: 12}, {name: '舟山', value: 12}, {name: '齐齐哈尔', value: 14}, {name: '盐城', value: 15}, {name: '赤峰', value: 16}, {name: '青岛', value: 18}, {name: '乳山', value: 18}, {name: '金昌', value: 19}, {name: '泉州', value: 21}, {name: '莱西', value: 21}, {name: '日照', value: 21}, {name: '胶南', value: 22}, {name: '南通', value: 23}, {name: '拉萨', value: 24}, {name: '云浮', value: 24}, {name: '梅州', value: 25}, {name: '文登', value: 25}, {name: '上海', value: 25}, {name: '攀枝花', value: 25}, {name: '威海', value: 25}, {name: '承德', value: 25}, {name: '厦门', value: 26}, {name: '汕尾', value: 26}, {name: '潮州', value: 26}, {name: '丹东', value: 27}, {name: '太仓', value: 27}, {name: '曲靖', value: 27}, {name: '烟台', value: 28}, {name: '福州', value: 29}, {name: '瓦房店', value: 30}, {name: '即墨', value: 30}, {name: '抚顺', value: 31}, {name: '玉溪', value: 31}, {name: '张家口', value: 31}, {name: '阳泉', value: 31}, {name: '莱州', value: 32}, {name: '湖州', value: 32}, {name: '汕头', value: 32}, {name: '昆山', value: 33}, {name: '宁波', value: 33}, {name: '湛江', value: 33}, {name: '揭阳', value: 34}, {name: '荣成', value: 34}, {name: '连云港', value: 35}, {name: '葫芦岛', value: 35}, {name: '常熟', value: 36}, {name: '东莞', value: 36}, {name: '河源', value: 36}, {name: '淮安', value: 36}, {name: '泰州', value: 36}, {name: '南宁', value: 37}, {name: '营口', value: 37}, {name: '惠州', value: 37}, {name: '江阴', value: 37}, {name: '蓬莱', value: 37}, {name: '韶关', value: 38}, {name: '嘉峪关', value: 38}, {name: '广州', value: 38}, {name: '延安', value: 38}, {name: '太原', value: 39}, {name: '清远', value: 39}, {name: '中山', value: 39}, {name: '昆明', value: 39}, {name: '寿光', value: 40}, {name: '盘锦', value: 40}, {name: '长治', value: 41}, {name: '深圳', value: 41}, {name: '珠海', value: 42}, {name: '宿迁', value: 43}, {name: '咸阳', value: 43}, {name: '铜川', value: 44}, {name: '平度', value: 44}, {name: '佛山', value: 44}, {name: '海口', value: 44}, {name: '江门', value: 45}, {name: '章丘', value: 45}, {name: '肇庆', value: 46}, {name: '大连', value: 47}, {name: '临汾', value: 47}, {name: '吴江', value: 47}, {name: '石嘴山', value: 49}, {name: '沈阳', value: 50}, {name: '苏州', value: 50}, {name: '茂名', value: 50}, {name: '嘉兴', value: 51}, {name: '长春', value: 51}, {name: '胶州', value: 52}, {name: '银川', value: 52}, {name: '张家港', value: 52}, {name: '三门峡', value: 53}, {name: '锦州', value: 54}, {name: '南昌', value: 54}, {name: '柳州', value: 54}, {name: '三亚', value: 54}, {name: '自贡', value: 56}, {name: '吉林', value: 56}, {name: '阳江', value: 57}, {name: '泸州', value: 57}, {name: '西宁', value: 57}, {name: '宜宾', value: 58}, {name: '呼和浩特', value: 58}, {name: '成都', value: 58}, {name: '大同', value: 58}, {name: '镇江', value: 59}, {name: '桂林', value: 59}, {name: '张家界', value: 59}, {name: '宜兴', value: 59}, {name: '北海', value: 60}, {name: '西安', value: 61}, {name: '金坛', value: 62}, {name: '东营', value: 62}, {name: '牡丹江', value: 63}, {name: '遵义', value: 63}, {name: '绍兴', value: 63}, {name: '扬州', value: 64}, {name: '常州', value: 64}, {name: '潍坊', value: 65}, {name: '重庆', value: 66}, {name: '台州', value: 67}, {name: '南京', value: 67}, {name: '滨州', value: 70}, {name: '贵阳', value: 71}, {name: '无锡', value: 71}, {name: '本溪', value: 71}, {name: '克拉玛依', value: 72}, {name: '渭南', value: 72}, {name: '马鞍山', value: 72}, {name: '宝鸡', value: 72}, {name: '焦作', value: 75}, {name: '句容', value: 75}, {name: '北京', value: 79}, {name: '徐州', value: 79}, {name: '衡水', value: 80}, {name: '包头', value: 80}, {name: '绵阳', value: 80}, {name: '乌鲁木齐', value: 84}, {name: '枣庄', value: 84}, {name: '杭州', value: 84}, {name: '淄博', value: 85}, {name: '鞍山', value: 86}, {name: '溧阳', value: 86}, {name: '库尔勒', value: 86}, {name: '安阳', value: 90}, {name: '开封', value: 90}, {name: '济南', value: 92}, {name: '德阳', value: 93}, {name: '温州', value: 95}, {name: '九江', value: 96}, {name: '邯郸', value: 98}, {name: '临安', value: 99}, {name: '兰州', value: 99}, {name: '沧州', value: 100}, {name: '临沂', value: 103}, {name: '南充', value: 104}, {name: '天津', value: 105}, {name: '富阳', value: 106}, {name: '泰安', value: 112}, {name: '诸暨', value: 112}, {name: '郑州', value: 113}, {name: '哈尔滨', value: 114}, {name: '聊城', value: 116}, {name: '芜湖', value: 117}, {name: '唐山', value: 119}, {name: '平顶山', value: 119}, {name: '邢台', value: 119}, {name: '德州', value: 120}, {name: '济宁', value: 120}, {name: '荆州', value: 127}, {name: '宜昌', value: 130}, {name: '义乌', value: 132}, {name: '丽水', value: 133}, {name: '洛阳', value: 134}, {name: '秦皇岛', value: 136}, {name: '株洲', value: 143}, {name: '石家庄', value: 147}, {name: '莱芜', value: 148}, {name: '常德', value: 152}, {name: '保定', value: 153}, {name: '湘潭', value: 154}, {name: '金华', value: 157}, {name: '岳阳', value: 169}, {name: '长沙', value: 175}, {name: '衢州', value: 177}, {name: '廊坊', value: 193}, {name: '菏泽', value: 194}, {name: '合肥', value: 229}, {name: '武汉', value: 273}, {name: '大庆', value: 279} ]; var $ = function (id) { return document.getElementById(id) }; var $cityBox = $('cityBox'); var $input = $('inp'); var preVal = $input.value; //重点将input内容进行search var engine = new PinyinEngine(demoData,['name']); //初始加载 loadCity(demoData); //加载所有数据 function loadCity(data) { //判断是否为空 if(data.length === 0){ var $li = document.createElement("li"); $li.innerText = '未找到！！！！！！'; $cityBox.appendChild($li); return false; } //循环插入 for (var i=0;i&lt;data.length;i++){ var $li = document.createElement("li"); $li.innerText = data[i].name; $cityBox.appendChild($li) } } //input改变进行search $input.oninput = $input.onpropertychange = function () { var val = $input.value; if (val === preVal) return; preVal = $input.value; if (val === '') { loadCity(demoData); } else { $cityBox.innerText = ''; var list = engine.query(val); loadCity(list); }; } &lt;/script&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>模糊查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vivo手机H5页面ERROR]]></title>
    <url>%2F2018%2F07%2F26%2Fvivo-error%2F</url>
    <content type="text"><![CDATA[今天收到用户反馈，vivo手机我们的app H5页面怎么显示的不对啊，让后我们就测试了好几个机型，华为、小米、oppo、酷派，都没有问题啊，安卓小哥虚拟机都用上了。 后来安卓小哥用vivo手机测试在log处发现了报错，让后打开js一看有这个 ` 符号，还有这个Array.from()，${ele}等。 这都是ES6语法啊，原来vivo手机居然不支持ES6 都这么久了vivo还不支持ES6！！！！！！ 错误纠正。 后来我们专门进行了测试，发现只有，ES6新增的模板字符串有问题，我们的app在vivo收手机上不起作用。别的语法都没有问题。在vivo手机自带的浏览器进行测试也是没有问题的。原谅我还黑了vivo一波。最后是我们app的内核有问题。。。。。。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>vivo error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX error参数及状态码]]></title>
    <url>%2F2018%2F07%2F11%2Fajax-error%2F</url>
    <content type="text"><![CDATA[先来看AJAX error 里有哪些参数1234567891011121314151617$.ajax(&#123; type:"post", url:"", dataType:"json", data:&#123;&#125;, success:function(res)&#123; console.log(res) &#125;, error: function(jqXHR, textStatus, errorThrown) &#123; console.log(jqXHR.readyState); console.log(jqXHR.status); console.log(jqXHR.statusText); console.log(jqXHR.responseText); console.log(textStatus); console.log(errorThrown); &#125;&#125;) 参数一（jqXHR）jqXHR是一个jqXHR对象，在Jquery1.4和1.4版本之前返回的是XMLHttpRequest对象，1.5版本以后则开始使用jqXHR对象，该对象是一个超集，就是该对象不仅包括XMLHttpRequest对象，还包含其他更多的详细属性和信息。 readyState当前状态0 － （未初始化）还没有调用send()方法1 － （载入）已调用send()方法，正在发送请求 ，服务器连接已建立2 － （载入完成）send()方法执行完成，已经接收到全部响应内容 ，请求已接收3 － （交互）正在解析响应内容 ， 请求处理中4 － （完成）响应内容解析完成，可以在客户端调用了，请求已完成，且响应已就绪 status返回的HTTP状态码，比如常见的404,500等错误代码。 statusText对应状态码的错误信息，比如404错误信息是not found,500是Internal Server Error。 responseText服务器响应返回的文本信息 参数二（textStatus）返回的是字符串类型，表示返回的状态，根据服务器不同的错误可能返回下面这些信息：”timeout”（超时）, “error”（错误）, “abort”(中止), “parsererror”（解析错误），还有可能返回空值。 参数三（errorThrown）也是字符串类型，表示服务器抛出返回的错误信息，如果产生的是HTTP错误，那么返回的信息就是HTTP状态码对应的错误信息，比如404的Not Found,500错误的Internal Server Error。 AJAX状态码说明0**—状态未初始化1**—请求收到，继续处理12100—客户必须继续发出请求101—客户要求服务器根据请求转换HTTP协议版本 2**—操作成功收到，分析、接受1234567200—交易成功201—提示知道新文件的URL202—接受和处理、但处理未完成203—返回信息不确定或不完整204—请求收到，但返回信息为空205—服务器完成了请求，用户代理必须复位当前已经浏览过的文件206—服务器已经完成了部分用户的GET请求 3**—完成此请求必须进一步处理12345678300—请求的资源可在多处得到301—删除请求数据302—在其他地址发现了请求数据303—建议客户访问其他URL或访问方式304—客户端已经执行了GET，但文件未变化305—请求的资源必须从服务器指定的地址得到306—前一版本HTTP中使用的代码，现行版本中不再使用307—申明请求的资源临时性删除 3**—完成此请求必须进一步处理12345678300—请求的资源可在多处得到301—删除请求数据302—在其他地址发现了请求数据303—建议客户访问其他URL或访问方式304—客户端已经执行了GET，但文件未变化305—请求的资源必须从服务器指定的地址得到306—前一版本HTTP中使用的代码，现行版本中不再使用307—申明请求的资源临时性删除 4**—请求包含一个错误语法或不能完成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748401—请求授权失败401.1-登录失败。 401.2-服务器配置导致登录失败。 401.3-由于ACL对资源的限制而未获得授权。 401.4-筛选器授权失败401.5-ISAPI/CGI应用程序授权失败。 401.7–访问被Web服务器上的URL授权策略拒绝。这个错误代码为IIS6.0所专用。 402—保留有效ChargeTo头响应403—请求不允许403.1-执行访问被禁止。 403.2-读访问被禁止。 403.3-写访问被禁止。 403.4-要求SSL。 403.5-要求SSL128。 403.6-IP地址被拒绝。 403.7-要求客户端证书。 403.8-站点访问被拒绝。 403.9-用户数过多。 403.10-配置无效。 403.11-密码更改。 403.12-拒绝访问映射表。 403.13-客户端证书被吊销。 403.14-拒绝目录列表。 403.15-超出客户端访问许可。 403.16-客户端证书不受信任或无效。 403.17-客户端证书已过期或尚未生效。 403.18-在当前的应用程序池中不能执行所请求的URL。这个错误代码为IIS6.0所专用。 403.19-不能为这个应用程序池中的客户端执行CGI。这个错误代码为IIS6.0所专用。 403.20-Passport登录失败。这个错误代码为IIS6.0所专用。 404—没有发现文件、查询或URl404.0-（无）–没有找到文件或目录。 404.1-无法在所请求的端口上访问Web站点。 404.2-Web服务扩展锁定策略阻止本请求。 404.3-MIME映射策略阻止本请求。 405—用户在Request-Line字段定义的方法不允许406—根据用户发送的Accept拖，请求资源不可访问407—类似401，用户必须首先在代理服务器上得到授权408—客户端没有在用户指定的饿时间内完成请求409—对当前资源状态，请求不能完成410—服务器上不再有此资源且无进一步的参考地址411—服务器拒绝用户定义的Content-Length属性请求412—一个或多个请求头字段在当前请求中错误413—请求的资源大于服务器允许的大小414—请求的资源URL长于服务器允许的长度415—请求资源不支持请求项目格式416—请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段417—服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求423–锁定的错误。 5**—服务器错误1234567891011121314500—服务器产生内部错误500.12-应用程序正忙于在Web服务器上重新启动。 500.13-Web服务器太忙。 500.15-不允许直接请求Global.asa。 500.16–UNC授权凭据不正确。这个错误代码为IIS6.0所专用。 500.18–URL授权存储不能打开。这个错误代码为IIS6.0所专用。 500.100-内部ASP错误。 501—服务器不支持请求的函数502—服务器暂时不可用，有时是为了防止发生系统过载502.1-CGI应用程序超时。 502.2-CGI应用程序出错。application. 503—服务器过载或暂停维修，这个错误代码为IIS6.0所专用。 504—关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长505—服务器不支持或拒绝支请求头中指定的HTTP版本]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>AJAX error</tag>
        <tag>AJAX 状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[event.stopPropagation()、event.stopPropagation()、 return false 理解与兼容]]></title>
    <url>%2F2018%2F07%2F10%2FstopPropagation%2F</url>
    <content type="text"><![CDATA[这个布局div里有一个a链接，我们队div和a都添加点击事件（使用jq方法添加点击事件）来查看效果。1234567891011&lt;div class="testBox"&gt; &lt;a href="https://www.baidu.com/" target="_blank"&gt;百度一下&lt;/a&gt;&lt;/div&gt;$('.testBox').click(function () &#123; console.log(1);&#125;);$('.testBox a').click(function () &#123; console.log(2);&#125;); 默认情况下控制台输出结果为2、1并且跳转打开链接。因为事件冒泡原理，DOM上触发事件后，通过DOM树往上，在每一级父元素上触发。有时候我们想先不执行跳转链接或者只执行当前DOM的事件，我们就用到下面的了。 event.preventDefault();//阻止默认行为1234$('.testBox a').click(function (event) &#123; event.preventDefault(); console.log(2);&#125;); 控制台输出结果为2、1链接没有跳转。阻止事件的默认行为，但不阻止冒泡。如果考虑IE还需要进行兼容（用三元表达式进行兼容）1event.preventDefault ? event.preventDefault() : event.returnValue=false; event.stopPropagation();//阻止事件冒泡1234$('.testBox a').click(function (event) &#123; event.stopPropagation(); console.log(2);&#125;); 控制台输出结果为2并且跳转打开链接。阻止事件的冒泡，但不阻止事件的默认行为。如果考虑IE还需要进行兼容（用三元表达式进行兼容）1event.stopPropagation ? event.stopPropagation() : event.cancelBubble=true; return false;1234$('.testBox a').get(0).addEventListener("click",function()&#123; return false; console.log(2);&#125;,false); 控制台输出结果为1并且跳转打开链接。若使用a.addEventListener,则return false 不会阻止默认行为；使用原生js时，若要阻止默认行为，最好还是用event.preventDefault（针对非IE）或event.returnValue=false（针对IE）来设定。1234$('.testBox a').click(function (event) &#123; return false; console.log(2);&#125;); 控制台没有输出结果链接也咩有进行跳转。使用a.onclick或a.attachEvent,则 return false会阻止默认行为；使用jquery，return false 即会阻止默认行为，也会阻止事件的冒泡。在jquery中，一般使用return false. 在使用的时候要注意return false;后面的代码不会执行。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>event.stopPropagation();</tag>
        <tag>event.preventDefault();</tag>
        <tag>return false;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间戳与时间获取]]></title>
    <url>%2F2018%2F07%2F09%2Ftimer%2F</url>
    <content type="text"><![CDATA[时间转时间戳1.Date.parse(new Date()) 不推荐这种办法，毫秒级别的数值被转化为00012var timestamp1 = Date.parse(new Date());console.log(timestamp1); //1531100204000 2.(new Date()).valueOf() 通过valueOf()函数返回指定对象的原始值获得准确的时间戳值12var timestamp2 = (new Date()).valueOf();console.log(timestamp2); //1531100216013 3.new Date().getTime() 通过原型方法直接获得当前时间的毫秒值，准确12var timestamp3 = new Date().getTime();console.log(timestamp3); //1531100225639 4.Number(new Date()) 将时间转化为一个number类型的数值，即时间戳12var timetamp4 = Number(new Date());console.log(timetamp4); //1531100238110 5.Date.now() ES5给Date提供了一种获取时间戳的新特性12var timetamp5 = Date.now();console.log(timetamp5); //1531100248079 获取当前时间一个获取当前时间的函数，比较不错，好用。123456789101112131415161718192021222324252627282930313233Date.prototype.pattern=function(fmt) &#123; var o = &#123; "M+" : this.getMonth()+1, //月份 "d+" : this.getDate(), //日 "h+" : this.getHours()%12 == 0 ? 12 : this.getHours()%12, //小时 "H+" : this.getHours(), //小时 "m+" : this.getMinutes(), //分 "s+" : this.getSeconds(), //秒 "q+" : Math.floor((this.getMonth()+3)/3), //季度 "S" : this.getMilliseconds() //毫秒， &#125;; var week = &#123; "0" : "星期日", "1" : "星期一", "2" : "星期二", "3" : "星期三", "4" : "星期四", "5" : "星期五", "6" : "星期六" &#125;; if(/(y+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length)); &#125; if(/(E+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, ((RegExp.$1.length&gt;1) ? (RegExp.$1.length&gt;2 ? "/u661f/u671f" : "/u5468") : "")+week[this.getDay()+""]); &#125; for(var k in o)&#123; if(new RegExp("("+ k +")").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length))); &#125; &#125; return fmt;&#125; 使用方法如下 yyyy(年) MM(月) dd(日) HH(时) mm(分) ss(秒) 随意搭配可以调换顺序使用 console.log(new Date().pattern("HH:mm"));//09:41 console.log(new Date().pattern("yyyy-MM-dd HH:mm"));//2018-07-09 09:41 console.log(new Date().pattern("yyyy年MM月dd日 HH:mm"));//2018年07月09日 09:41 console.log(new Date().pattern("yyyy年MM月dd日 HH:mm:ss"));//2018年07月09日 09:41:55 console.log(new Date().pattern("HH:mm yyyy年MM月dd日 E"));//09:41 2018年07月09日 星期一 移动端比较不错的时间插件 lCalendar.js详情可以点击此链接查看 手机端日期插件lCalendar.js 多多记录，方便以后查看。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>时间戳</tag>
        <tag>当前时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[slice、splice、split、join、substring、substr]]></title>
    <url>%2F2018%2F07%2F08%2Fslice%2F</url>
    <content type="text"><![CDATA[slice()Array和String对象都有 在Array中 slice(i,[j]) i为开始截取的索引值,负数代表从末尾算起的索引值，-1为倒数第一个元素 j为结束的索引值，缺省时则获取从i到末尾的所有元素 参数返回： 返回索引值从i到j的数组，原数组不改变 在String中 slice(i,[j]) 参数说明： i为开始截取的索引值，负数代表从末尾算起的索引值，-1为倒数第一个字符 j为结束的索引值，缺省时则获取从i到末尾的所有字符 splice()存在Array中 方法向/从数组中添加/删除项目，然后返回被删除的项目。 该方法会改变原始数组 splice(index,howmany,item1,itemx ) index : 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany: 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1...itemX : 可选。向数组添加的新项目。 返回值 Array 包含被删除项目的新数组，如果有的话。 substring()在String中 substring(start,stop) start：表示子字符串的开始位置， stop：表示结束结果。 注意：第二个参数应该大于第一个参数。如果出现第一个参数大于第二个参数的情况，substring方法会自动更换两个参数的位置。 substr()在String中，substr（start，length）； start：子字符串的开始位置， length：子字符串的长度。 split() 字符串转数组在String中 split（separator，howmany） separator：必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。 howmany： 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 返回值 一个字符串数组。该数组是通过在separator指定的边界处将字符串StringObject分割成子串创建的。返回的数组的字符串不包含separator自身 但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本） 与jion（）函数相反效果 var str = 'ab+c+de'; var a = str.split('+'); // [ab, c, de] var b = str.split(''); //[a, b, +, c, +, d, e] join() 数组转字符串var a, b,c; a = new Array(a,b,c,d,e); b = a.join('-'); //a-b-c-d-e 使用-拼接数组元素 c = a.join(''); //abcde 多多记录，方便以后查看。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js截取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[append、appendto、prepend、prependto、after、before]]></title>
    <url>%2F2018%2F07%2F07%2Fappend%2F</url>
    <content type="text"><![CDATA[append()在被选元素（里）的结尾插入内容 表达式：$(selector).append(content); &lt;p&gt;Hello&lt;/p&gt; $('p').append('&lt;b&gt;Zyw&lt;/b&gt;'); &lt;p&gt; Hello &lt;b&gt;Zyw&lt;/b&gt; &lt;/p&gt; appendTo()在被选元素（里）的结尾插入内容 表达式：$(content).appendTo(selector); &lt;p&gt;Hello&lt;/p&gt; $('&lt;b&gt;Zyw&lt;/b&gt;').appendTo($('p')); &lt;p&gt; Hello &lt;b&gt;Zyw&lt;/b&gt; &lt;/p&gt; prepend()在被选元素（里）的开头插入内容 表达式：$(selector).prepend(content); &lt;p&gt;Hello&lt;/p&gt; $('p').prepend('&lt;b&gt;Zyw&lt;/b&gt;'); &lt;p&gt; &lt;b&gt;Zyw&lt;/b&gt; Hello &lt;/p&gt; prependTo()在被选元素（里）的开头插入内容 表达式：$(content).prependTo(selector); &lt;p&gt;Hello&lt;/p&gt; $('&lt;b&gt;Zyw&lt;/b&gt;').prependTo($('p')); &lt;p&gt; &lt;b&gt;Zyw&lt;/b&gt; Hello &lt;/p&gt; after()在被选元素（外）之后插入内容 表达式：$(selector).after(content); &lt;p&gt;Hello&lt;/p&gt; $('p').after('&lt;b&gt;Zyw&lt;/b&gt;'); &lt;p&gt;Hello&lt;/p&gt; &lt;b&gt;Zyw&lt;/b&gt; before()在被选元素（外）之前插入内容 表达式：$(selector).before(content); &lt;p&gt;Hello&lt;/p&gt; $('p').before('&lt;b&gt;Zyw&lt;/b&gt;'); &lt;b&gt;Zyw&lt;/b&gt; &lt;p&gt;Hello&lt;/p&gt; 多多记录，方便以后查看。]]></content>
      <categories>
        <category>jq</category>
      </categories>
      <tags>
        <tag>jq插入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F06%2F28%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Miss Dad感觉过了人生过了好久，哪怕在没有时间也要抽出时间陪陪家人，不要失去了才知道珍惜。好久没有写博客了，因为个人原因在加上换了电脑不想在用jekyll写了，觉得太麻烦，这几天工作不是很忙就像在把博客弄回来，选择了Hexo,还是比较方便的。 下面只记录一下常用的Hexo命令，方便以后回看。 hexo new新建一篇标题为 My New Post 的文章，因为标题里有空格，所以加上了引号。文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。1$ hexo new "My New Post" hexo server/hexo s启动本地服务器，用于预览主题。默认地址： http://localhost:4000/hexo s 是 hexo server 的缩写，命令效果一致；预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。1$ hexo server/hexo s hexo generate/hexo g生成网站静态文件到默认设置的 public 文件夹。便于查看网站生成的静态文件或者手动部署网站；如果使用自动部署，不需要先执行该命令；hexo g 是 hexo generate 的缩写，命令效果一致。1$ hexo generate/hexo g hexo deploy/hexo d自动生成网站静态文件，并部署到设定的仓库。hexo d 是 hexo deploy 的缩写，命令效果一致。1$ hexo deploy/hexo d hexo clean清除缓存文件 db.json 和已生成的静态文件 public 。网站显示异常时可以执行这条命令试试。1$ hexo clean]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图+echarts3]]></title>
    <url>%2F2017%2F08%2F15%2Fecharts%2Bbaidu%2F</url>
    <content type="text"><![CDATA[准备工作本文介绍的是将百度地图和echarts3版本进行结合使用，首先你需要有百度的AK，没有的话去百度地图开放平台http://lbsyun.baidu.com/,用百度账号（没有的申请一个）,让后去申请一个ak吧，具体怎么做，可以去度娘一下，好多的，进去找到JavaScript API里面也会有申请方法的，很简单的。 让后去echarts3官网去下载echarts3吧http://echarts.baidu.com/download.html 然后我们还需要一个bmap.js，大家可以点击这里下载bmap.js谷歌浏览器会有安全提示，你可以不用理他，如果你不放心，你可以点击这里在线预览bmap.js，在自己电脑中新建一个bmap.js的文件，把他们复制进去。 先看一下效果吧 var myChart = echarts.init(document.getElementById('map')); var data = [ {name: '海门', value: 9}, {name: '鄂尔多斯', value: 12}, {name: '招远', value: 12}, {name: '舟山', value: 12}, {name: '齐齐哈尔', value: 14}, {name: '盐城', value: 15}, {name: '赤峰', value: 16}, {name: '青岛', value: 18}, {name: '乳山', value: 18}, {name: '金昌', value: 19}, {name: '泉州', value: 21}, {name: '莱西', value: 21}, {name: '日照', value: 21}, {name: '胶南', value: 22}, {name: '南通', value: 23}, {name: '拉萨', value: 24}, {name: '云浮', value: 24}, {name: '梅州', value: 25}, {name: '文登', value: 25}, {name: '上海', value: 25}, {name: '攀枝花', value: 25}, {name: '威海', value: 25}, {name: '承德', value: 25}, {name: '厦门', value: 26}, {name: '汕尾', value: 26}, {name: '潮州', value: 26}, {name: '丹东', value: 27}, {name: '太仓', value: 27}, {name: '曲靖', value: 27}, {name: '烟台', value: 28}, {name: '福州', value: 29}, {name: '瓦房店', value: 30}, {name: '即墨', value: 30}, {name: '抚顺', value: 31}, {name: '玉溪', value: 31}, {name: '张家口', value: 31}, {name: '阳泉', value: 31}, {name: '莱州', value: 32}, {name: '湖州', value: 32}, {name: '汕头', value: 32}, {name: '昆山', value: 33}, {name: '宁波', value: 33}, {name: '湛江', value: 33}, {name: '揭阳', value: 34}, {name: '荣成', value: 34}, {name: '连云港', value: 35}, {name: '葫芦岛', value: 35}, {name: '常熟', value: 36}, {name: '东莞', value: 36}, {name: '河源', value: 36}, {name: '淮安', value: 36}, {name: '泰州', value: 36}, {name: '南宁', value: 37}, {name: '营口', value: 37}, {name: '惠州', value: 37}, {name: '江阴', value: 37}, {name: '蓬莱', value: 37}, {name: '韶关', value: 38}, {name: '嘉峪关', value: 38}, {name: '广州', value: 38}, {name: '延安', value: 38}, {name: '太原', value: 39}, {name: '清远', value: 39}, {name: '中山', value: 39}, {name: '昆明', value: 39}, {name: '寿光', value: 40}, {name: '盘锦', value: 40}, {name: '长治', value: 41}, {name: '深圳', value: 41}, {name: '珠海', value: 42}, {name: '宿迁', value: 43}, {name: '咸阳', value: 43}, {name: '铜川', value: 44}, {name: '平度', value: 44}, {name: '佛山', value: 44}, {name: '海口', value: 44}, {name: '江门', value: 45}, {name: '章丘', value: 45}, {name: '肇庆', value: 46}, {name: '大连', value: 47}, {name: '临汾', value: 47}, {name: '吴江', value: 47}, {name: '石嘴山', value: 49}, {name: '沈阳', value: 50}, {name: '苏州', value: 50}, {name: '茂名', value: 50}, {name: '嘉兴', value: 51}, {name: '长春', value: 51}, {name: '胶州', value: 52}, {name: '银川', value: 52}, {name: '张家港', value: 52}, {name: '三门峡', value: 53}, {name: '锦州', value: 54}, {name: '南昌', value: 54}, {name: '柳州', value: 54}, {name: '三亚', value: 54}, {name: '自贡', value: 56}, {name: '吉林', value: 56}, {name: '阳江', value: 57}, {name: '泸州', value: 57}, {name: '西宁', value: 57}, {name: '宜宾', value: 58}, {name: '呼和浩特', value: 58}, {name: '成都', value: 58}, {name: '大同', value: 58}, {name: '镇江', value: 59}, {name: '桂林', value: 59}, {name: '张家界', value: 59}, {name: '宜兴', value: 59}, {name: '北海', value: 60}, {name: '西安', value: 61}, {name: '金坛', value: 62}, {name: '东营', value: 62}, {name: '牡丹江', value: 63}, {name: '遵义', value: 63}, {name: '绍兴', value: 63}, {name: '扬州', value: 64}, {name: '常州', value: 64}, {name: '潍坊', value: 65}, {name: '重庆', value: 66}, {name: '台州', value: 67}, {name: '南京', value: 67}, {name: '滨州', value: 70}, {name: '贵阳', value: 71}, {name: '无锡', value: 71}, {name: '本溪', value: 71}, {name: '克拉玛依', value: 72}, {name: '渭南', value: 72}, {name: '马鞍山', value: 72}, {name: '宝鸡', value: 72}, {name: '焦作', value: 75}, {name: '句容', value: 75}, {name: '北京', value: 79}, {name: '徐州', value: 79}, {name: '衡水', value: 80}, {name: '包头', value: 80}, {name: '绵阳', value: 80}, {name: '乌鲁木齐', value: 84}, {name: '枣庄', value: 84}, {name: '杭州', value: 84}, {name: '淄博', value: 85}, {name: '鞍山', value: 86}, {name: '溧阳', value: 86}, {name: '库尔勒', value: 86}, {name: '安阳', value: 90}, {name: '开封', value: 90}, {name: '济南', value: 92}, {name: '德阳', value: 93}, {name: '温州', value: 95}, {name: '九江', value: 96}, {name: '邯郸', value: 98}, {name: '临安', value: 99}, {name: '兰州', value: 99}, {name: '沧州', value: 100}, {name: '临沂', value: 103}, {name: '南充', value: 104}, {name: '天津', value: 105}, {name: '富阳', value: 106}, {name: '泰安', value: 112}, {name: '诸暨', value: 112}, {name: '郑州', value: 113}, {name: '哈尔滨', value: 114}, {name: '聊城', value: 116}, {name: '芜湖', value: 117}, {name: '唐山', value: 119}, {name: '平顶山', value: 119}, {name: '邢台', value: 119}, {name: '德州', value: 120}, {name: '济宁', value: 120}, {name: '荆州', value: 127}, {name: '宜昌', value: 130}, {name: '义乌', value: 132}, {name: '丽水', value: 133}, {name: '洛阳', value: 134}, {name: '秦皇岛', value: 136}, {name: '株洲', value: 143}, {name: '石家庄', value: 147}, {name: '莱芜', value: 148}, {name: '常德', value: 152}, {name: '保定', value: 153}, {name: '湘潭', value: 154}, {name: '金华', value: 157}, {name: '岳阳', value: 169}, {name: '长沙', value: 175}, {name: '衢州', value: 177}, {name: '廊坊', value: 193}, {name: '菏泽', value: 194}, {name: '合肥', value: 229}, {name: '武汉', value: 273}, {name: '大庆', value: 279} ]; var geoCoordMap = { '海门':[121.15,31.89], '鄂尔多斯':[109.781327,39.608266], '招远':[120.38,37.35], '舟山':[122.207216,29.985295], '齐齐哈尔':[123.97,47.33], '盐城':[120.13,33.38], '赤峰':[118.87,42.28], '青岛':[120.33,36.07], '乳山':[121.52,36.89], '金昌':[102.188043,38.520089], '泉州':[118.58,24.93], '莱西':[120.53,36.86], '日照':[119.46,35.42], '胶南':[119.97,35.88], '南通':[121.05,32.08], '拉萨':[91.11,29.97], '云浮':[112.02,22.93], '梅州':[116.1,24.55], '文登':[122.05,37.2], '上海':[121.48,31.22], '攀枝花':[101.718637,26.582347], '威海':[122.1,37.5], '承德':[117.93,40.97], '厦门':[118.1,24.46], '汕尾':[115.375279,22.786211], '潮州':[116.63,23.68], '丹东':[124.37,40.13], '太仓':[121.1,31.45], '曲靖':[103.79,25.51], '烟台':[121.39,37.52], '福州':[119.3,26.08], '瓦房店':[121.979603,39.627114], '即墨':[120.45,36.38], '抚顺':[123.97,41.97], '玉溪':[102.52,24.35], '张家口':[114.87,40.82], '阳泉':[113.57,37.85], '莱州':[119.942327,37.177017], '湖州':[120.1,30.86], '汕头':[116.69,23.39], '昆山':[120.95,31.39], '宁波':[121.56,29.86], '湛江':[110.359377,21.270708], '揭阳':[116.35,23.55], '荣成':[122.41,37.16], '连云港':[119.16,34.59], '葫芦岛':[120.836932,40.711052], '常熟':[120.74,31.64], '东莞':[113.75,23.04], '河源':[114.68,23.73], '淮安':[119.15,33.5], '泰州':[119.9,32.49], '南宁':[108.33,22.84], '营口':[122.18,40.65], '惠州':[114.4,23.09], '江阴':[120.26,31.91], '蓬莱':[120.75,37.8], '韶关':[113.62,24.84], '嘉峪关':[98.289152,39.77313], '广州':[113.23,23.16], '延安':[109.47,36.6], '太原':[112.53,37.87], '清远':[113.01,23.7], '中山':[113.38,22.52], '昆明':[102.73,25.04], '寿光':[118.73,36.86], '盘锦':[122.070714,41.119997], '长治':[113.08,36.18], '深圳':[114.07,22.62], '珠海':[113.52,22.3], '宿迁':[118.3,33.96], '咸阳':[108.72,34.36], '铜川':[109.11,35.09], '平度':[119.97,36.77], '佛山':[113.11,23.05], '海口':[110.35,20.02], '江门':[113.06,22.61], '章丘':[117.53,36.72], '肇庆':[112.44,23.05], '大连':[121.62,38.92], '临汾':[111.5,36.08], '吴江':[120.63,31.16], '石嘴山':[106.39,39.04], '沈阳':[123.38,41.8], '苏州':[120.62,31.32], '茂名':[110.88,21.68], '嘉兴':[120.76,30.77], '长春':[125.35,43.88], '胶州':[120.03336,36.264622], '银川':[106.27,38.47], '张家港':[120.555821,31.875428], '三门峡':[111.19,34.76], '锦州':[121.15,41.13], '南昌':[115.89,28.68], '柳州':[109.4,24.33], '三亚':[109.511909,18.252847], '自贡':[104.778442,29.33903], '吉林':[126.57,43.87], '阳江':[111.95,21.85], '泸州':[105.39,28.91], '西宁':[101.74,36.56], '宜宾':[104.56,29.77], '呼和浩特':[111.65,40.82], '成都':[104.06,30.67], '大同':[113.3,40.12], '镇江':[119.44,32.2], '桂林':[110.28,25.29], '张家界':[110.479191,29.117096], '宜兴':[119.82,31.36], '北海':[109.12,21.49], '西安':[108.95,34.27], '金坛':[119.56,31.74], '东营':[118.49,37.46], '牡丹江':[129.58,44.6], '遵义':[106.9,27.7], '绍兴':[120.58,30.01], '扬州':[119.42,32.39], '常州':[119.95,31.79], '潍坊':[119.1,36.62], '重庆':[106.54,29.59], '台州':[121.420757,28.656386], '南京':[118.78,32.04], '滨州':[118.03,37.36], '贵阳':[106.71,26.57], '无锡':[120.29,31.59], '本溪':[123.73,41.3], '克拉玛依':[84.77,45.59], '渭南':[109.5,34.52], '马鞍山':[118.48,31.56], '宝鸡':[107.15,34.38], '焦作':[113.21,35.24], '句容':[119.16,31.95], '北京':[116.46,39.92], '徐州':[117.2,34.26], '衡水':[115.72,37.72], '包头':[110,40.58], '绵阳':[104.73,31.48], '乌鲁木齐':[87.68,43.77], '枣庄':[117.57,34.86], '杭州':[120.19,30.26], '淄博':[118.05,36.78], '鞍山':[122.85,41.12], '溧阳':[119.48,31.43], '库尔勒':[86.06,41.68], '安阳':[114.35,36.1], '开封':[114.35,34.79], '济南':[117,36.65], '德阳':[104.37,31.13], '温州':[120.65,28.01], '九江':[115.97,29.71], '邯郸':[114.47,36.6], '临安':[119.72,30.23], '兰州':[103.73,36.03], '沧州':[116.83,38.33], '临沂':[118.35,35.05], '南充':[106.110698,30.837793], '天津':[117.2,39.13], '富阳':[119.95,30.07], '泰安':[117.13,36.18], '诸暨':[120.23,29.71], '郑州':[113.65,34.76], '哈尔滨':[126.63,45.75], '聊城':[115.97,36.45], '芜湖':[118.38,31.33], '唐山':[118.02,39.63], '平顶山':[113.29,33.75], '邢台':[114.48,37.05], '德州':[116.29,37.45], '济宁':[116.59,35.38], '荆州':[112.239741,30.335165], '宜昌':[111.3,30.7], '义乌':[120.06,29.32], '丽水':[119.92,28.45], '洛阳':[112.44,34.7], '秦皇岛':[119.57,39.95], '株洲':[113.16,27.83], '石家庄':[114.48,38.03], '莱芜':[117.67,36.19], '常德':[111.69,29.05], '保定':[115.48,38.85], '湘潭':[112.91,27.87], '金华':[119.64,29.12], '岳阳':[113.09,29.37], '长沙':[113,28.21], '衢州':[118.88,28.97], '廊坊':[116.7,39.53], '菏泽':[115.480656,35.23375], '合肥':[117.27,31.86], '武汉':[114.31,30.52], '大庆':[125.03,46.58] }; var convertData = function (data) { var res = []; for (var i = 0; i < data.length; i++) { var geoCoord = geoCoordMap[data[i].name]; if (geoCoord) { res.push({ name: data[i].name, value: geoCoord.concat(data[i].value) }); } } return res; }; option = { title: { text: '全国主要城市空气质量 - 百度地图', subtext: 'data from PM25.in', sublink: 'http://www.pm25.in', left: 'center' }, tooltip : { trigger: 'item' }, bmap: { center: [104.114129, 37.550339], zoom: 5, roam: true, mapStyle: { styleJson: [{ 'featureType': 'water', 'elementType': 'all', 'stylers': { 'color': '#d1d1d1' } }, { 'featureType': 'land', 'elementType': 'all', 'stylers': { 'color': '#f3f3f3' } }, { 'featureType': 'railway', 'elementType': 'all', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'highway', 'elementType': 'all', 'stylers': { 'color': '#fdfdfd' } }, { 'featureType': 'highway', 'elementType': 'labels', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'arterial', 'elementType': 'geometry', 'stylers': { 'color': '#fefefe' } }, { 'featureType': 'arterial', 'elementType': 'geometry.fill', 'stylers': { 'color': '#fefefe' } }, { 'featureType': 'poi', 'elementType': 'all', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'green', 'elementType': 'all', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'subway', 'elementType': 'all', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'manmade', 'elementType': 'all', 'stylers': { 'color': '#d1d1d1' } }, { 'featureType': 'local', 'elementType': 'all', 'stylers': { 'color': '#d1d1d1' } }, { 'featureType': 'arterial', 'elementType': 'labels', 'stylers': { 'visibility': 'off' } }, { 'featureType': 'boundary', 'elementType': 'all', 'stylers': { 'color': '#fefefe' } }, { 'featureType': 'building', 'elementType': 'all', 'stylers': { 'color': '#d1d1d1' } }, { 'featureType': 'label', 'elementType': 'labels.text.fill', 'stylers': { 'color': '#999999' } }] } }, series : [ { name: 'pm2.5', type: 'scatter', coordinateSystem: 'bmap', data: convertData(data), symbolSize: function (val) { return val[2] / 10; }, label: { normal: { formatter: '{b}', position: 'right', show: false }, emphasis: { show: true } }, itemStyle: { normal: { color: 'purple' } } }, { name: 'Top 5', type: 'effectScatter', coordinateSystem: 'bmap', data: convertData(data.sort(function (a, b) { return b.value - a.value; }).slice(0, 6)), symbolSize: function (val) { return val[2] / 10; }, showEffectOn: 'render', rippleEffect: { brushType: 'stroke' }, hoverAnimation: true, label: { normal: { formatter: '{b}', position: 'right', show: true } }, itemStyle: { normal: { color: 'purple', shadowBlur: 10, shadowColor: '#333' } }, zlevel: 1 } ] }; myChart.setOption(option); 头部引入1234567&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;百度地图+echarts3&lt;/title&gt; &lt;script src="echarts.min.js"&gt;&lt;/script&gt;//引入echarts &lt;script src="bmap.js"&gt;&lt;/script&gt;//引入bmap &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=F28AEuS9TLiQeFkEPrktcpk44toP1D0e"&gt;&lt;/script&gt;//引入你申请的ak&lt;/head&gt; js部分代码在这里就把有用的拿出来说一下，下面会给大家所有的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159bmap: &#123;//这里就是写百度地图的一些场景 center: [104.114129, 37.550339],//中心显示位置，经纬度 zoom: 5,//放大倍数 roam: true,//允许放大 mapStyle: &#123; styleJson: [&#123;//水的颜色 'featureType': 'water', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123;//土地颜色 'featureType': 'land', 'elementType': 'all', 'stylers': &#123; 'color': '#f3f3f3' &#125; &#125;, &#123;//下面这些标签都是调整地图的，大家可以自行研究 'featureType': 'railway', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'highway', 'elementType': 'all', 'stylers': &#123; 'color': '#fdfdfd' &#125; &#125;, &#123; 'featureType': 'highway', 'elementType': 'labels', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'arterial', 'elementType': 'geometry', 'stylers': &#123; 'color': '#fefefe' &#125; &#125;, &#123; 'featureType': 'arterial', 'elementType': 'geometry.fill', 'stylers': &#123; 'color': '#fefefe' &#125; &#125;, &#123; 'featureType': 'poi', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'green', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'subway', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'manmade', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'local', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'arterial', 'elementType': 'labels', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'boundary', 'elementType': 'all', 'stylers': &#123; 'color': '#fefefe' &#125; &#125;, &#123; 'featureType': 'building', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'label', 'elementType': 'labels.text.fill', 'stylers': &#123; 'color': '#999999' &#125; &#125;] &#125; &#125;, series : [//下面的就是echarts的参数设置 &#123; name: '名称', type: 'scatter',//散点（气泡）图 coordinateSystem: 'bmap', data: convertData(data), symbolSize: 6, label: &#123; normal: &#123; formatter: '&#123;b&#125;', position: 'right', show: false &#125;, emphasis: &#123; show: true &#125; &#125;, itemStyle: &#123; normal: &#123; color: 'purple' &#125; &#125; &#125;, &#123; name: 'Top 5', type: 'effectScatter',//带有涟漪特效动画的散点（气泡）图 coordinateSystem: 'bmap', data: convertData(data.sort(function (a, b) &#123; return b.value - a.value; &#125;).slice(0, 6)), symbolSize: function (val) &#123; return val[2] / 10; &#125;, showEffectOn: 'render', rippleEffect: &#123; brushType: 'stroke' &#125;, hoverAnimation: true, label: &#123; normal: &#123; formatter: '&#123;b&#125;', position: 'right', show: true &#125; &#125;, itemStyle: &#123; normal: &#123; color: 'purple', shadowBlur: 10, shadowColor: '#333' &#125; &#125;, zlevel: 1 &#125; ] all代码所有的代码都在这了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;百度地图+echarts3&lt;/title&gt; &lt;script src="echarts.min.js"&gt;&lt;/script&gt; &lt;script src="bmap.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=F28AEuS9TLiQeFkEPrktcpk44toP1D0e"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="map" style="width: 800px;height: 600px;"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var myChart = echarts.init(document.getElementById('map')); var data = [ &#123;name: '海门', value: 9&#125;, &#123;name: '鄂尔多斯', value: 12&#125;, &#123;name: '招远', value: 12&#125;, &#123;name: '舟山', value: 12&#125;, &#123;name: '齐齐哈尔', value: 14&#125;, &#123;name: '盐城', value: 15&#125;, &#123;name: '赤峰', value: 16&#125;, &#123;name: '青岛', value: 18&#125;, &#123;name: '乳山', value: 18&#125;, &#123;name: '金昌', value: 19&#125;, &#123;name: '泉州', value: 21&#125;, &#123;name: '莱西', value: 21&#125;, &#123;name: '日照', value: 21&#125;, &#123;name: '胶南', value: 22&#125;, &#123;name: '南通', value: 23&#125;, &#123;name: '拉萨', value: 24&#125;, &#123;name: '云浮', value: 24&#125;, &#123;name: '梅州', value: 25&#125;, &#123;name: '文登', value: 25&#125;, &#123;name: '上海', value: 25&#125;, &#123;name: '攀枝花', value: 25&#125;, &#123;name: '威海', value: 25&#125;, &#123;name: '承德', value: 25&#125;, &#123;name: '厦门', value: 26&#125;, &#123;name: '汕尾', value: 26&#125;, &#123;name: '潮州', value: 26&#125;, &#123;name: '丹东', value: 27&#125;, &#123;name: '太仓', value: 27&#125;, &#123;name: '曲靖', value: 27&#125;, &#123;name: '烟台', value: 28&#125;, &#123;name: '福州', value: 29&#125;, &#123;name: '瓦房店', value: 30&#125;, &#123;name: '即墨', value: 30&#125;, &#123;name: '抚顺', value: 31&#125;, &#123;name: '玉溪', value: 31&#125;, &#123;name: '张家口', value: 31&#125;, &#123;name: '阳泉', value: 31&#125;, &#123;name: '莱州', value: 32&#125;, &#123;name: '湖州', value: 32&#125;, &#123;name: '汕头', value: 32&#125;, &#123;name: '昆山', value: 33&#125;, &#123;name: '宁波', value: 33&#125;, &#123;name: '湛江', value: 33&#125;, &#123;name: '揭阳', value: 34&#125;, &#123;name: '荣成', value: 34&#125;, &#123;name: '连云港', value: 35&#125;, &#123;name: '葫芦岛', value: 35&#125;, &#123;name: '常熟', value: 36&#125;, &#123;name: '东莞', value: 36&#125;, &#123;name: '河源', value: 36&#125;, &#123;name: '淮安', value: 36&#125;, &#123;name: '泰州', value: 36&#125;, &#123;name: '南宁', value: 37&#125;, &#123;name: '营口', value: 37&#125;, &#123;name: '惠州', value: 37&#125;, &#123;name: '江阴', value: 37&#125;, &#123;name: '蓬莱', value: 37&#125;, &#123;name: '韶关', value: 38&#125;, &#123;name: '嘉峪关', value: 38&#125;, &#123;name: '广州', value: 38&#125;, &#123;name: '延安', value: 38&#125;, &#123;name: '太原', value: 39&#125;, &#123;name: '清远', value: 39&#125;, &#123;name: '中山', value: 39&#125;, &#123;name: '昆明', value: 39&#125;, &#123;name: '寿光', value: 40&#125;, &#123;name: '盘锦', value: 40&#125;, &#123;name: '长治', value: 41&#125;, &#123;name: '深圳', value: 41&#125;, &#123;name: '珠海', value: 42&#125;, &#123;name: '宿迁', value: 43&#125;, &#123;name: '咸阳', value: 43&#125;, &#123;name: '铜川', value: 44&#125;, &#123;name: '平度', value: 44&#125;, &#123;name: '佛山', value: 44&#125;, &#123;name: '海口', value: 44&#125;, &#123;name: '江门', value: 45&#125;, &#123;name: '章丘', value: 45&#125;, &#123;name: '肇庆', value: 46&#125;, &#123;name: '大连', value: 47&#125;, &#123;name: '临汾', value: 47&#125;, &#123;name: '吴江', value: 47&#125;, &#123;name: '石嘴山', value: 49&#125;, &#123;name: '沈阳', value: 50&#125;, &#123;name: '苏州', value: 50&#125;, &#123;name: '茂名', value: 50&#125;, &#123;name: '嘉兴', value: 51&#125;, &#123;name: '长春', value: 51&#125;, &#123;name: '胶州', value: 52&#125;, &#123;name: '银川', value: 52&#125;, &#123;name: '张家港', value: 52&#125;, &#123;name: '三门峡', value: 53&#125;, &#123;name: '锦州', value: 54&#125;, &#123;name: '南昌', value: 54&#125;, &#123;name: '柳州', value: 54&#125;, &#123;name: '三亚', value: 54&#125;, &#123;name: '自贡', value: 56&#125;, &#123;name: '吉林', value: 56&#125;, &#123;name: '阳江', value: 57&#125;, &#123;name: '泸州', value: 57&#125;, &#123;name: '西宁', value: 57&#125;, &#123;name: '宜宾', value: 58&#125;, &#123;name: '呼和浩特', value: 58&#125;, &#123;name: '成都', value: 58&#125;, &#123;name: '大同', value: 58&#125;, &#123;name: '镇江', value: 59&#125;, &#123;name: '桂林', value: 59&#125;, &#123;name: '张家界', value: 59&#125;, &#123;name: '宜兴', value: 59&#125;, &#123;name: '北海', value: 60&#125;, &#123;name: '西安', value: 61&#125;, &#123;name: '金坛', value: 62&#125;, &#123;name: '东营', value: 62&#125;, &#123;name: '牡丹江', value: 63&#125;, &#123;name: '遵义', value: 63&#125;, &#123;name: '绍兴', value: 63&#125;, &#123;name: '扬州', value: 64&#125;, &#123;name: '常州', value: 64&#125;, &#123;name: '潍坊', value: 65&#125;, &#123;name: '重庆', value: 66&#125;, &#123;name: '台州', value: 67&#125;, &#123;name: '南京', value: 67&#125;, &#123;name: '滨州', value: 70&#125;, &#123;name: '贵阳', value: 71&#125;, &#123;name: '无锡', value: 71&#125;, &#123;name: '本溪', value: 71&#125;, &#123;name: '克拉玛依', value: 72&#125;, &#123;name: '渭南', value: 72&#125;, &#123;name: '马鞍山', value: 72&#125;, &#123;name: '宝鸡', value: 72&#125;, &#123;name: '焦作', value: 75&#125;, &#123;name: '句容', value: 75&#125;, &#123;name: '北京', value: 79&#125;, &#123;name: '徐州', value: 79&#125;, &#123;name: '衡水', value: 80&#125;, &#123;name: '包头', value: 80&#125;, &#123;name: '绵阳', value: 80&#125;, &#123;name: '乌鲁木齐', value: 84&#125;, &#123;name: '枣庄', value: 84&#125;, &#123;name: '杭州', value: 84&#125;, &#123;name: '淄博', value: 85&#125;, &#123;name: '鞍山', value: 86&#125;, &#123;name: '溧阳', value: 86&#125;, &#123;name: '库尔勒', value: 86&#125;, &#123;name: '安阳', value: 90&#125;, &#123;name: '开封', value: 90&#125;, &#123;name: '济南', value: 92&#125;, &#123;name: '德阳', value: 93&#125;, &#123;name: '温州', value: 95&#125;, &#123;name: '九江', value: 96&#125;, &#123;name: '邯郸', value: 98&#125;, &#123;name: '临安', value: 99&#125;, &#123;name: '兰州', value: 99&#125;, &#123;name: '沧州', value: 100&#125;, &#123;name: '临沂', value: 103&#125;, &#123;name: '南充', value: 104&#125;, &#123;name: '天津', value: 105&#125;, &#123;name: '富阳', value: 106&#125;, &#123;name: '泰安', value: 112&#125;, &#123;name: '诸暨', value: 112&#125;, &#123;name: '郑州', value: 113&#125;, &#123;name: '哈尔滨', value: 114&#125;, &#123;name: '聊城', value: 116&#125;, &#123;name: '芜湖', value: 117&#125;, &#123;name: '唐山', value: 119&#125;, &#123;name: '平顶山', value: 119&#125;, &#123;name: '邢台', value: 119&#125;, &#123;name: '德州', value: 120&#125;, &#123;name: '济宁', value: 120&#125;, &#123;name: '荆州', value: 127&#125;, &#123;name: '宜昌', value: 130&#125;, &#123;name: '义乌', value: 132&#125;, &#123;name: '丽水', value: 133&#125;, &#123;name: '洛阳', value: 134&#125;, &#123;name: '秦皇岛', value: 136&#125;, &#123;name: '株洲', value: 143&#125;, &#123;name: '石家庄', value: 147&#125;, &#123;name: '莱芜', value: 148&#125;, &#123;name: '常德', value: 152&#125;, &#123;name: '保定', value: 153&#125;, &#123;name: '湘潭', value: 154&#125;, &#123;name: '金华', value: 157&#125;, &#123;name: '岳阳', value: 169&#125;, &#123;name: '长沙', value: 175&#125;, &#123;name: '衢州', value: 177&#125;, &#123;name: '廊坊', value: 193&#125;, &#123;name: '菏泽', value: 194&#125;, &#123;name: '合肥', value: 229&#125;, &#123;name: '武汉', value: 273&#125;, &#123;name: '大庆', value: 279&#125; ]; var geoCoordMap = &#123; '海门':[121.15,31.89], '鄂尔多斯':[109.781327,39.608266], '招远':[120.38,37.35], '舟山':[122.207216,29.985295], '齐齐哈尔':[123.97,47.33], '盐城':[120.13,33.38], '赤峰':[118.87,42.28], '青岛':[120.33,36.07], '乳山':[121.52,36.89], '金昌':[102.188043,38.520089], '泉州':[118.58,24.93], '莱西':[120.53,36.86], '日照':[119.46,35.42], '胶南':[119.97,35.88], '南通':[121.05,32.08], '拉萨':[91.11,29.97], '云浮':[112.02,22.93], '梅州':[116.1,24.55], '文登':[122.05,37.2], '上海':[121.48,31.22], '攀枝花':[101.718637,26.582347], '威海':[122.1,37.5], '承德':[117.93,40.97], '厦门':[118.1,24.46], '汕尾':[115.375279,22.786211], '潮州':[116.63,23.68], '丹东':[124.37,40.13], '太仓':[121.1,31.45], '曲靖':[103.79,25.51], '烟台':[121.39,37.52], '福州':[119.3,26.08], '瓦房店':[121.979603,39.627114], '即墨':[120.45,36.38], '抚顺':[123.97,41.97], '玉溪':[102.52,24.35], '张家口':[114.87,40.82], '阳泉':[113.57,37.85], '莱州':[119.942327,37.177017], '湖州':[120.1,30.86], '汕头':[116.69,23.39], '昆山':[120.95,31.39], '宁波':[121.56,29.86], '湛江':[110.359377,21.270708], '揭阳':[116.35,23.55], '荣成':[122.41,37.16], '连云港':[119.16,34.59], '葫芦岛':[120.836932,40.711052], '常熟':[120.74,31.64], '东莞':[113.75,23.04], '河源':[114.68,23.73], '淮安':[119.15,33.5], '泰州':[119.9,32.49], '南宁':[108.33,22.84], '营口':[122.18,40.65], '惠州':[114.4,23.09], '江阴':[120.26,31.91], '蓬莱':[120.75,37.8], '韶关':[113.62,24.84], '嘉峪关':[98.289152,39.77313], '广州':[113.23,23.16], '延安':[109.47,36.6], '太原':[112.53,37.87], '清远':[113.01,23.7], '中山':[113.38,22.52], '昆明':[102.73,25.04], '寿光':[118.73,36.86], '盘锦':[122.070714,41.119997], '长治':[113.08,36.18], '深圳':[114.07,22.62], '珠海':[113.52,22.3], '宿迁':[118.3,33.96], '咸阳':[108.72,34.36], '铜川':[109.11,35.09], '平度':[119.97,36.77], '佛山':[113.11,23.05], '海口':[110.35,20.02], '江门':[113.06,22.61], '章丘':[117.53,36.72], '肇庆':[112.44,23.05], '大连':[121.62,38.92], '临汾':[111.5,36.08], '吴江':[120.63,31.16], '石嘴山':[106.39,39.04], '沈阳':[123.38,41.8], '苏州':[120.62,31.32], '茂名':[110.88,21.68], '嘉兴':[120.76,30.77], '长春':[125.35,43.88], '胶州':[120.03336,36.264622], '银川':[106.27,38.47], '张家港':[120.555821,31.875428], '三门峡':[111.19,34.76], '锦州':[121.15,41.13], '南昌':[115.89,28.68], '柳州':[109.4,24.33], '三亚':[109.511909,18.252847], '自贡':[104.778442,29.33903], '吉林':[126.57,43.87], '阳江':[111.95,21.85], '泸州':[105.39,28.91], '西宁':[101.74,36.56], '宜宾':[104.56,29.77], '呼和浩特':[111.65,40.82], '成都':[104.06,30.67], '大同':[113.3,40.12], '镇江':[119.44,32.2], '桂林':[110.28,25.29], '张家界':[110.479191,29.117096], '宜兴':[119.82,31.36], '北海':[109.12,21.49], '西安':[108.95,34.27], '金坛':[119.56,31.74], '东营':[118.49,37.46], '牡丹江':[129.58,44.6], '遵义':[106.9,27.7], '绍兴':[120.58,30.01], '扬州':[119.42,32.39], '常州':[119.95,31.79], '潍坊':[119.1,36.62], '重庆':[106.54,29.59], '台州':[121.420757,28.656386], '南京':[118.78,32.04], '滨州':[118.03,37.36], '贵阳':[106.71,26.57], '无锡':[120.29,31.59], '本溪':[123.73,41.3], '克拉玛依':[84.77,45.59], '渭南':[109.5,34.52], '马鞍山':[118.48,31.56], '宝鸡':[107.15,34.38], '焦作':[113.21,35.24], '句容':[119.16,31.95], '北京':[116.46,39.92], '徐州':[117.2,34.26], '衡水':[115.72,37.72], '包头':[110,40.58], '绵阳':[104.73,31.48], '乌鲁木齐':[87.68,43.77], '枣庄':[117.57,34.86], '杭州':[120.19,30.26], '淄博':[118.05,36.78], '鞍山':[122.85,41.12], '溧阳':[119.48,31.43], '库尔勒':[86.06,41.68], '安阳':[114.35,36.1], '开封':[114.35,34.79], '济南':[117,36.65], '德阳':[104.37,31.13], '温州':[120.65,28.01], '九江':[115.97,29.71], '邯郸':[114.47,36.6], '临安':[119.72,30.23], '兰州':[103.73,36.03], '沧州':[116.83,38.33], '临沂':[118.35,35.05], '南充':[106.110698,30.837793], '天津':[117.2,39.13], '富阳':[119.95,30.07], '泰安':[117.13,36.18], '诸暨':[120.23,29.71], '郑州':[113.65,34.76], '哈尔滨':[126.63,45.75], '聊城':[115.97,36.45], '芜湖':[118.38,31.33], '唐山':[118.02,39.63], '平顶山':[113.29,33.75], '邢台':[114.48,37.05], '德州':[116.29,37.45], '济宁':[116.59,35.38], '荆州':[112.239741,30.335165], '宜昌':[111.3,30.7], '义乌':[120.06,29.32], '丽水':[119.92,28.45], '洛阳':[112.44,34.7], '秦皇岛':[119.57,39.95], '株洲':[113.16,27.83], '石家庄':[114.48,38.03], '莱芜':[117.67,36.19], '常德':[111.69,29.05], '保定':[115.48,38.85], '湘潭':[112.91,27.87], '金华':[119.64,29.12], '岳阳':[113.09,29.37], '长沙':[113,28.21], '衢州':[118.88,28.97], '廊坊':[116.7,39.53], '菏泽':[115.480656,35.23375], '合肥':[117.27,31.86], '武汉':[114.31,30.52], '大庆':[125.03,46.58] &#125;; var convertData = function (data) &#123; var res = []; for (var i = 0; i &lt; data.length; i++) &#123; var geoCoord = geoCoordMap[data[i].name]; if (geoCoord) &#123; res.push(&#123; name: data[i].name, value: geoCoord.concat(data[i].value) &#125;); &#125; &#125; return res; &#125;; option = &#123; title: &#123; text: '全国主要城市空气质量 - 百度地图', subtext: 'data from PM25.in', sublink: 'http://www.pm25.in', left: 'center' &#125;, tooltip : &#123; trigger: 'item' &#125;, bmap: &#123; center: [104.114129, 37.550339], zoom: 5, roam: true, mapStyle: &#123; styleJson: [&#123; 'featureType': 'water', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'land', 'elementType': 'all', 'stylers': &#123; 'color': '#f3f3f3' &#125; &#125;, &#123; 'featureType': 'railway', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'highway', 'elementType': 'all', 'stylers': &#123; 'color': '#fdfdfd' &#125; &#125;, &#123; 'featureType': 'highway', 'elementType': 'labels', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'arterial', 'elementType': 'geometry', 'stylers': &#123; 'color': '#fefefe' &#125; &#125;, &#123; 'featureType': 'arterial', 'elementType': 'geometry.fill', 'stylers': &#123; 'color': '#fefefe' &#125; &#125;, &#123; 'featureType': 'poi', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'green', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'subway', 'elementType': 'all', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'manmade', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'local', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'arterial', 'elementType': 'labels', 'stylers': &#123; 'visibility': 'off' &#125; &#125;, &#123; 'featureType': 'boundary', 'elementType': 'all', 'stylers': &#123; 'color': '#fefefe' &#125; &#125;, &#123; 'featureType': 'building', 'elementType': 'all', 'stylers': &#123; 'color': '#d1d1d1' &#125; &#125;, &#123; 'featureType': 'label', 'elementType': 'labels.text.fill', 'stylers': &#123; 'color': '#999999' &#125; &#125;] &#125; &#125;, series : [ &#123; name: 'pm2.5', type: 'scatter', coordinateSystem: 'bmap', data: convertData(data), symbolSize: function (val) &#123; return val[2] / 10; &#125;, label: &#123; normal: &#123; formatter: '&#123;b&#125;', position: 'right', show: false &#125;, emphasis: &#123; show: true &#125; &#125;, itemStyle: &#123; normal: &#123; color: 'purple' &#125; &#125; &#125;, &#123; name: 'Top 5', type: 'effectScatter', coordinateSystem: 'bmap', data: convertData(data.sort(function (a, b) &#123; return b.value - a.value; &#125;).slice(0, 6)), symbolSize: function (val) &#123; return val[2] / 10; &#125;, showEffectOn: 'render', rippleEffect: &#123; brushType: 'stroke' &#125;, hoverAnimation: true, label: &#123; normal: &#123; formatter: '&#123;b&#125;', position: 'right', show: true &#125; &#125;, itemStyle: &#123; normal: &#123; color: 'purple', shadowBlur: 10, shadowColor: '#333' &#125; &#125;, zlevel: 1 &#125; ] &#125;; myChart.setOption(option);&lt;/script&gt;&lt;/html&gt; 今天就写到这里了，欢迎大家交流讨论，指错。]]></content>
      <categories>
        <category>echarts3</category>
      </categories>
      <tags>
        <tag>百度地图</tag>
        <tag>echarts3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3选择器]]></title>
    <url>%2F2017%2F07%2F31%2Fnth%2F</url>
    <content type="text"><![CDATA[磨叨两句上来先磨叨两句，用这个选择器已经很久了，但是一直用的都是:nth-of-type这个，:nth-child只是记得，几乎没有用过，最开始知道这两个选择器的时候，肯定两个都用过，但最后一直就用:nth-of-type了，原因我也忘记了，前几天用到:nth-of-type这个选择器，突然忘了他和:nth-child的具体区别是什么了，所以在这里，在回顾一下。 child和of-type 家族123456child 家族:first-child p:first-child 选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。:nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。:last-child p:last-child 选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素。:only-child p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 123456of-type 家族:first-of-type p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。:nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。:nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。:last-of-type p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。:only-of-type p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :nth-of-type(n)和:nth-child(n)对比这两个家族别的选择器还好说，就:nth-of-type(n)和:nth-child(n)他们俩用的时候还会有一些问题，下面用具体例子来体会一下。 1234567891011121314&lt;body&gt;&lt;style&gt;p:nth-child(2)&#123; background: red;&#125;p:nth-of-type(2)&#123; background: red;&#125;&lt;/style&gt;&lt;div&gt; &lt;p&gt;我是p1&lt;/p&gt; &lt;p&gt;我是p2&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 此时分别使用这两个css选择器进行渲染时，页面显示的效果是一样的，look 然后我们稍稍改一下再看一下效果 123456789101112131415&lt;body&gt;&lt;style&gt;p:nth-child(2)&#123; background: red;&#125;p:nth-of-type(2)&#123; background: red;&#125;&lt;/style&gt;&lt;div&gt; &lt;div&gt;我是div1&lt;/div&gt; &lt;p&gt;我是p1&lt;/p&gt; &lt;p&gt;我是p2&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 这一下就不友好了，字面理解一下啊，child儿子嘛，第二个儿子，还是个p标签，正好给你变个色吧。而p:nth-of-type(2)他就会去找p标签的第二个，这样我的心里感觉才是我想要的结果我们在加一个div看看啊12345678910111213141516&lt;body&gt;&lt;style&gt;p:nth-child(2)&#123; background: red;&#125;/*p:nth-of-type(2)&#123; background: red;&#125;*/&lt;/style&gt;&lt;div&gt; &lt;div&gt;我是div1&lt;/div&gt; &lt;div&gt;我是div2&lt;/div&gt; &lt;p&gt;我是p1&lt;/p&gt; &lt;p&gt;我是p2&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 看吧，第二个儿子，没有p标签啊，那算了吧，谁也不给上色了。 个人建议找元素，还是用:nth-of-type()，毕竟不用太费脑子，而且照的还快、准、稳。 浏览器兼容情况：所有主流浏览器均支持，除了 IE8 及更早的版本。毕竟是css3新添加的嘛。 上面详细的对比了一组，下面在简单对比一下别的 p:first-child和p:first-of-type p:nth-last-child(n)和p:nth-last-of-type(n)注意哦：last是从后往前数楼！！ p:last-child和p:last-of-type p:only-child和p:only-of-type因为他是only了，这里div和p都是两个所以不成立，就都不上色了。改成这样在看看，123456789&lt;body&gt;&lt;style&gt;p:only-child&#123;background: red;&#125;p:only-of-type&#123;background: red;&#125;&lt;/style&gt;&lt;div&gt; &lt;div&gt;我是唯一的div&lt;/div&gt; &lt;p&gt;我是唯一的p&lt;/p&gt;&lt;/div&gt; 总结一下是不是有点感觉了，小小的总结一下child家的成员在进行选择的时候不仅要选择元素，而且还要选择当前位置对不对，only的话那就只能有p(拿p举一下例子啊)，div哥哥来了就不高兴了，就不给你显示。 of-type家的成员在进行选择的时候不管你里面有哪个哥哥弟弟p、div、span，选择器元素写好了，他就会按照当前的元素进行查找。 个人还是倾向于of-type家的。快、准、稳，哈哈，今天就到这了，忙了好久，终于有点时间了，上来晃一圈。 如有错误之处，欢迎指正。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>:nth-child</tag>
        <tag>:nth-of-type</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css calc()]]></title>
    <url>%2F2017%2F07%2F06%2Fcss-calc%2F</url>
    <content type="text"><![CDATA[css calc() 介绍像 calc() var() 这样的，乍一看还以为是函数呢，其实他们都是属于CSS的，calc()做自适应布局还是很好用的，其实用box-sizing也是可以的，但是calc()强大到，可以用公式做计算，+、-、*、/，如果你在你点电脑打开win+r输入calc回车，你会发现，系统会自动调出计算器来。其实calc()是css3的一个新功能，可以用来做响应式布局，响应式布局宽度是变化的，这样用calc()就可以实现宽度的动态加载。 css calc() 语法calc()语法非常简单，就像我们小时候学加 （+）、减（-）、乘（*）、除（/）一样，使用数学表达式来表示：123.ele &#123; width: calc(expression);&#125; 其中”expression”是一个表达式，用来计算长度的表达式。 calc()的运算规则calc()使用通用的数学运算规则，但是也提供更智能的功能：12345使用“+”、“-”、“*” 和 “/”四则运算；1.可以使用百分比、px、em、rem等单位；2.可以混合使用各种单位进行计算；3.表达式中有“+”和“-”时，其前后必须要有空格，没有空格的写法是错误的；4.表达式中有“*”和“/”时，其前后可以没有空格，但建议留有空格。 calc()实战小例子12345678910111213141516171819&lt;style&gt; *&#123; margin:0; padding:0; &#125; body&#123; width:100%; background-color: #333; &#125; div&#123; width:100%; height:200px; padding: 20px; background-color: #666; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 此时就会发现div把body的身体挤破了，出现横向滚动条了，解决方法可以用 box-sizing: border-box;要是用calc()就可以这样写12345678910111213141516171819&lt;style&gt; *&#123; margin:0; padding:0; &#125; body&#123; width:100%; background-color: #333; &#125; div&#123; `width:calc(100% - 20px * 2);` height:200px; padding: 20px; background-color: #666; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 这样也是可以解决的，calc()做响应式开发是很不错的。 calc()响应式开发例子做响应式开啊还需要使用到上一章所说道的变量var(),这两个相结合可以很便捷的进行响应式开发，直接上代码吧。 你也可以点击这里然后变化浏览器窗口大小进行预览 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;style&gt; :root&#123; --columns: 3; &#125; .box&#123; width:80%; min-width: 300px; margin: auto; border: 2px solid #333; overflow: hidden; &#125; .calc&#123; width: calc(100% / var(--columns) - 10px * 2); background: #aaa; margin: 10px; float: left; &#125; *&#123; margin:0; padding:0; &#125; h5&#123; width:100%; height:60px; text-align: center; line-height:60px; font-size: 26px; color: #fff; &#125; p&#123; padding-top:60px; height: 140px; &#125; img&#123; display: block; margin: auto; &#125; @media screen and ( max-width: 992px) &#123; :root&#123; --columns: 2; &#125; &#125; @media screen and ( max-width: 768px) &#123; :root&#123; --columns: 1; &#125; &#125;&lt;/style&gt;&lt;body style="background: #666"&gt; &lt;div class="box"&gt; &lt;div class="calc"&gt; &lt;h5&gt;子鼠&lt;/h5&gt; &lt;p&gt;&lt;img src="img/shu.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;丑牛&lt;/h5&gt; &lt;p&gt;&lt;img src="img/niu.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;寅虎&lt;/h5&gt; &lt;p&gt;&lt;img src="img/hu.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;卯兔&lt;/h5&gt; &lt;p&gt;&lt;img src="img/tu.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;辰龙&lt;/h5&gt; &lt;p&gt;&lt;img src="img/long.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;巳蛇&lt;/h5&gt; &lt;p&gt;&lt;img src="img/she.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;午马&lt;/h5&gt; &lt;p&gt;&lt;img src="img/ma.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;未羊&lt;/h5&gt; &lt;p&gt;&lt;img src="img/yang.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;申猴&lt;/h5&gt; &lt;p&gt;&lt;img src="img/hou.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;酉鸡&lt;/h5&gt; &lt;p&gt;&lt;img src="img/ji.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;戌狗&lt;/h5&gt; &lt;p&gt;&lt;img src="img/gou.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="calc"&gt; &lt;h5&gt;亥猪&lt;/h5&gt; &lt;p&gt;&lt;img src="img/zhu.png" alt=""&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 感觉很厉害，就是变量var()对浏览器的兼容还不是很好，要是决绝了IE那就太厉害了。 calc()兼容性这个的兼容性还是很好的，不考虑ie8以下的还是可以放心用的，有人说在使用的时候需要加浏览器前缀，像这样的12345678.ele &#123; /*Firefox*/ -moz-calc(expression); /*chrome safari*/ -webkit-calc(expression); /*Standard */ calc(); &#125; 我实际测试了以下，不加前缀也可以用的。 如有错误之处，欢迎指正。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css calc()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css变量]]></title>
    <url>%2F2017%2F07%2F05%2Fcss-variable%2F</url>
    <content type="text"><![CDATA[css变量介绍随着CSS预编译工具Sass/Less/Stylus的关注和逐渐流行，CSS工作组迅速跟进CSS变量的规范制定，并且，很多浏览器已经跟进，目前，在部分项目中已经可以直接使用了。变量的好处就是可以降低维护成本，附带还有更高性能。 css变量使用语法CSS中原生的变量定义语法是：–，变量使用语法是：var(–)，其中*表示我们的变量名称。 关于命名这个东西，各种语言都有些显示，例如CSS选择器不能是数字开头，JS中的变量是不能直接数值的，但是，在CSS变量中，这些限制通通没有，还可以是中文，但是不能包含$，[，^，(，%等字符，普通字符局限在只要是“数字[0-9]”“字母[a-zA-Z]”“下划线_”和“短横线-”这些组合。123456:root &#123; --666: #666;&#125;body &#123; background-color: var(--666);&#125; 或者这样，有了中文还怕啥！123456:root &#123; --灰色: #666;&#125;body &#123; background-color: var(--灰色);&#125; 无论是变量的定义和使用只能在声明块{}里面，例如，下面这样是无效的：1234--灰色: #666;body &#123; background-color: var(--灰色);&#125; 1234567:root&#123; background-color: var(--灰色);/*:root代表根元素html,所以在这里面定义的变量属于全局变量。*/&#125;div &#123; --background-color: #333;/*此时定义的变量只适用于div元素下，属于局部变量*/ background-color: var(--background-color);&#125; 变量的属性使用也是有权重的，其实可以把CSS的原生变量理解为一种CSS属性。这样，你就对其权重和变量应用规则要容易理解地多。使用起来也就更加方便了，来看一个例子。12345678910111213141516171819202122&lt;style&gt; :root &#123; --color: purple; &#125; div &#123; --color: green; &#125; #alert &#123; --color: red; &#125; * &#123; color: var(--color); &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;我的紫色继承于根元素&lt;/p&gt; &lt;div&gt;我的绿色来自直接设置&lt;/div&gt; &lt;div id='alert'&gt; ID选择器权重更高，因此我是红色！ &lt;p&gt;我也是红色，占了继承的光&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 变量也是跟着CSS选择器走的，如果变量所在的选择器和使用变量的元素没有交集，是没有效果的。例如#alert定义的变量，只有id为alert的元素才能享有。如果你想变量全局使用，则你可以设置在:root选择器上； 当存在多个同样名称的变量时候，变量的覆盖规则由CSS选择器的权重决定的，但并无!important这种用法，因为没有必要，!important设计初衷是干掉JS的style设置，但对于变量的定义则没有这样的需求。 注意 CSS属性名不可以走变量、CSS变量不支持同时多个声明 CSS变量使用完整语法CSS变量使用的完整语法为：var( [, ]? )，用中文表示就是：var( &lt;自定义属性名&gt; [, &lt;默认值 ]? )， 意思就是，如果我们使用的变量没有定义（注意，仅限于没有定义），则使用后面的值作为元素的属性值。举个例子：123456.box &#123; --background-color: #666;&#125;body &#123; background-color: var(--background-color, #f60);&#125; 则此时的背景色是#f60 CSS变量不合法的缺省特性请看下面这个例子：12345body &#123; --color: 20px; background-color: #369; background-color: var(--color, #cd0000);&#125; 请问，此时的背景色是？1A. transparent B. 20px C. #369 D. #cd0000 答案是…………………………A. transparent 这是CSS变量非常有意思的一个点，对于CSS变量，只要语法是正确的，就算变量里面的值是个乱七八糟的东西，也是会作为正常的声明解析，如果发现变量值是不合法的，例如上面背景色显然不能是20px，则使用背景色的缺省值，也就是默认值代替，于是，上面CSS等同于：12345body &#123; --color: 20px; background-color: #369; background-color: transparent;&#125; 千万不能想当然得认为等同于background-color:20px，这也是为什么上面要强调CSS默认值的使用仅限于变量未定义的情况，并不包括变量不合法。 CSS变量的空格尾随特性请看下面这个例子：1234body &#123; --size: 20; font-size: var(--size)px;&#125; 如果你以为的font-size是20px就太天真了，实际上，此处font-size:var(–size)px等同于font-size:20 px，注意，20后面有个空格，所以，这里的font-size使用的是元素默认的大小。因此，就不要妄图取消就使用一个数值来贯穿全场，还是使用稳妥的做法：1234body &#123; --size: 20px; font-size: var(--size);&#125; 或者使用CSS3 calc()计算：下一章在介绍CSS calc()1234body &#123; --size: 20; font-size: calc(var(--size) * 1px);&#125; 此时，的font-size大小才是20px， CSS变量的相互传递特性就是说，我们在CSS变量定义的时候可以直接引入其他变量给自己使用，例如：1234body &#123; --green: #4CAF50; --backgroundColor: var(--green);&#125; CSS变量兼容性ie全家都被pass了，感觉很不好。 如有错误之处，欢迎指正。 参考网址：http://www.zhangxinxu.com/wordpress/?p=5804]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于网页打印的一些问题]]></title>
    <url>%2F2017%2F06%2F27%2Fhtml-print%2F</url>
    <content type="text"><![CDATA[有的时候我们需要把web页面进行打印出来，并且要在a4纸上完美呈现，开始的时候我笨打算把网页转换为分页的pdf，这样在本地就可以打印了。 我使用了html2canvas+jspdf这两个神器结合起来来达到我要的效果。 html2canvas是对整个或局部页面进行‘截图’。但这并不是真的截图，而是通过遍历页面DOM结构，收集所有元素信息及相应样式，渲染出canvas image。简单理解为就是把你想要打印的页面进行渲染成为一张图片了， 使用1234567891011121314使用的API也很简洁，下面代码可以将某个元素渲染成canvas：html2canvas(element, &#123; onrendered: function(canvas) &#123; // canvas is the final rendered &lt;canvas&gt; element &#125;&#125;);通过onrendered方法，可以将生成的canvas进行回调，比如插入到页面中：html2canvas(element, &#123; onrendered: function(canvas) &#123; document.body.appendChild(canvas); &#125;&#125;); 想了解更多关于html2canvas的请移步这里 jspdf是一个客户端解决方案生成pdf文件，可以将字体，图片生成pdf,还是很实用的。 文字生成PDF，使用方法如下：123456// 默认a4大小，竖直方向，mm单位的PDFvar doc = new jsPDF();// 添加文本‘Download PDF’doc.text('Download PDF!', 10, 10);doc.save('a4.pdf'); 图片生成PDF，使用方法如下：12345678// 三个参数，第一个方向，第二个单位，第三个尺寸格式var doc = new jsPDF('landscape','pt',[205, 115])// 将图片转化为dataUrlvar imageData = ‘data:image/png;base64,iVBORw0KGgo...’;doc.addImage(imageData, 'PNG', 0, 0, 205, 115);doc.save('a4.pdf'); 文字与图片生成PDF，使用方法如下：123456789101112131415// 三个参数，第一个方向，第二个尺寸，第三个尺寸格式var doc = new jsPDF('landscape','pt',[205, 155])// 将图片转化为dataUrlvar imageData = ‘data:image/png;base64,iVBORw0KGgo...’;//设置字体大小doc.setFontSize(20);//10,20这两参数控制文字距离左边，与上边的距离doc.text('Stone', 10, 20);// 0, 40, 控制文字距离左边，与上边的距离doc.addImage(imageData, 'PNG', 0, 40, 205, 115);doc.save('a4.pdf') 想了解更多关于jspdf的请移步这里 html2canvas + jsPDF，使用方法如下：12345678910111213141516171819202122&lt;script type="text/javascript" src="./js/jsPdf.debug.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var downPdf = document.getElementById("renderPdf"); downPdf.onclick = function() &#123; html2canvas(document.body, &#123; onrendered:function(canvas) &#123; //返回图片dataURL，参数：图片格式和清晰度(0-1) var pageData = canvas.toDataURL('image/jpeg', 1.0); //方向默认竖直，尺寸ponits，格式a4[595.28,841.89] var pdf = new jsPDF('', 'pt', 'a4'); //addImage后两个参数控制添加图片的尺寸，此处将页面高度按照a4纸宽高比列进行压缩 pdf.addImage(pageData, 'JPEG', 0, 0, 595.28, 592.28/canvas.width * canvas.height ); pdf.save('stone.pdf'); &#125; &#125;) &#125;&lt;/script&gt; html2canvas + jsPDF，加上分页效果，使用方法如下：123456789101112131415161718192021222324252627282930313233343536373839html2canvas(document.body, &#123; onrendered:function(canvas) &#123; var contentWidth = canvas.width; var contentHeight = canvas.height; //一页pdf显示html页面生成的canvas高度; var pageHeight = contentWidth / 592.28 * 841.89; //未生成pdf的html页面高度 var leftHeight = contentHeight; //页面偏移 var position = 0; //a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高 var imgWidth = 595.28; var imgHeight = 592.28/contentWidth * contentHeight; var pageData = canvas.toDataURL('image/jpeg', 1.0); var pdf = new jsPDF('', 'pt', 'a4'); //有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89) //当内容未超过pdf一页显示的范围，无需分页 if (leftHeight &lt; pageHeight) &#123; pdf.addImage(pageData, 'JPEG', 0, 0, imgWidth, imgHeight ); &#125; else &#123; while(leftHeight &gt; 0) &#123; pdf.addImage(pageData, 'JPEG', 0, position, imgWidth, imgHeight) leftHeight -= pageHeight; position -= 841.89; //避免添加空白页 if(leftHeight &gt; 0) &#123; pdf.addPage(); &#125; &#125; &#125; pdf.save('content.pdf'); &#125;&#125;) 以上内容参考地址 这两个前端空间单用起来兼容性都是很好的，但是和在一起就出现一些问题了。使用后在谷歌浏览器下开始是没有问题的但是页面太多就会出现黑页面情况（毕竟我的页面有40多页A4纸大小），在火狐下会出现某一页出现黑页面的现象，在ie下就报错了。这个方案就被我pass掉了。 后来发现浏览器自带的打印功能，print() 方法用于打印当前窗口的内容。 首先在介绍这个方法之前要要先介绍一个css3的标签，就是@media 查询，一般使用它都是在调整浏览器大小的时候改变样式什么的，看一下他的媒体类型12345值 描述all 用于所有设备print 用于打印机和打印预览screen 用于电脑屏幕，平板电脑，智能手机等。speech 应用于屏幕阅读器等发声设备 通过这个标签就可以控制打印的时候的纸张大小123456@media print &#123; .bg_page&#123; width: 297mm; height: 210mm; &#125;&#125; 还要介绍一个属性page-break-after 设置在元素之后进行分页的分页行为1234567值 描述auto 默认。如果必要则在元素后插入分页符。always 在元素后插入分页符。avoid 避免在元素后插入分页符。left 在元素之后足够的分页符，一直到一张空白的左页为止。right 在元素之后足够的分页符，一直到一张空白的右页为止。inherit 规定应该从父元素继承 page-break-after 属性的设置。 在加上这个属性后就可以调用打印机进行打印了。1234567@media print &#123; .bg_page&#123; width: 297mm; height: 210mm; page-break-after:always; &#125;&#125; 需要注意的是：如果页面太长，要打印的很多，要是还有一些动画，或者canvas一系列的，需要当页面全部加载完之后，在调用window.print()方法or(Ctrl+p)，否则答应出来的页面显示不全，最好是先用可以预览的浏览器进行预览像谷歌这样的，比较好。]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>print</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vertical-align]]></title>
    <url>%2F2017%2F06%2F12%2Fvertical-align%2F</url>
    <content type="text"><![CDATA[在前端页面开发过程中，经常会碰到向nav导航的布局，一张图片加上字体说明（现在实现这种效果用iconfont也是很不错的），别的地方也有很多需要用到这种组合的形式，默认的样式是这样的。一般都是需要图片居中显示的，以前我的做法都是将图片进行浮动让后再调整图片位置，偶然间发现css有一个这一个属性vertical-align，感觉很实用，发现新大陆了。看一下w3school对他的解释。12345678910111213141516171819202122232425浏览器支持 所有浏览器都支持 vertical-align 属性。 注释：任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 "inherit"。定义和用法 vertical-align 属性设置元素的垂直对齐方式。说明 该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。 这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。 默认值： baseline 继承性： no 版本： CSS1 JavaScript 语法： object.style.verticalAlign="bottom"可能的值 值 描述 baseline 默认。元素放置在父元素的基线上。 sub 垂直对齐文本的下标。 super 垂直对齐文本的上标 top 把元素的顶端与行中最高元素的顶端对齐 text-top 把元素的顶端与父元素字体的顶端对齐 middle 把此元素放置在父元素的中部。 bottom 把元素的顶端与行中最低的元素的顶端对齐。 text-bottom 把元素的底端与父元素字体的底端对齐。 length % 使用 "line-height" 属性的百分比值来排列此元素。允许使用负值。 inherit 规定应该从父元素继承 vertical-align 属性的值。 给我刚才的例子添加上vertical-align:middle属性，看一下效果一下子就达到了我想要的效果，感觉很不错吧 其他的属性值也很好理解，多多记忆一下就好了。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>vertical-align</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象（OO）]]></title>
    <url>%2F2017%2F06%2F06%2Foo%2F</url>
    <content type="text"><![CDATA[什么是面向对象？什么是面向对象？–&gt;一切皆对象！！！ 什么是对象，不知道这个东西里面长得什么样子，但是知道这个东西有什么功能和方法会用就行了，这就是对象，就像js里面的那些个对象，date呀，数组呀，咱们不知道内部是个什么原理，但是咱们知道它的属性和方法，其实对象就是一个整体，对外提供一些功能和操作，面向对象其实是一种通用思想，可以在编程中用，也可以在生活中用，在编程中呢，如何在使用某些功能来实现效果的过程中可以只关注功能，不关注内部细节的编程思想，就是面向对象就像jq，咱们知道jq可以用$(“.a”)来获取一个jq的dom对象，咱们学习jq不需要去学习jq是怎么去获取dom对象的，只需要学习用jq获取对象的那个操作就ok了，那么jq就是用面向对象编程思想来编写的一个类库。 面向对象的特点抽象：抽指把核心的东西抽出来，把与我们要解决的问题有关的东西拿出来摆在面前 封装：让使用对象的人不考虑内部实现，只考虑功能使用 把内部的代码保护起来，只留出一些个api接口供用户使用 继承：就是为了代码的复用，从父类上继承出一些方法和属性，子类也有自己的一些属性，多重继承继承多种方法和属性 多态，对于咱们的js这种弱类型语言来说其实意义不大 对象的组成属性 变量：状态、静态的 方法 函数：过程、动态的 创建对象-基础创建最简单的方法就是基础创建12345678var obj=new Object();obj.name = 'wei';obj.age = 6;obj.height = 180obj.showName = function() &#123; alert(this.name)&#125;console.log(obj)//Object &#123;name: "wei", age: 6, height: 180, showName: function&#125; 基础创建缺点：创建一次写一回，如果创建一百次呢，那样就太复杂了，产生了很多重复的代码。 创建对象-工厂模式工厂模式抽象了创建具体对象的过程，使用函数封装以特定接口创建对象123456789101112131415161718192021function creatPerson (name,age,height)&#123; var obj = new Object(); obj.name = name; obj.age = age; obj.height = height; obj.showName = function () &#123; alert(this.name) &#125; return obj;&#125;var person1 = creatPerson("wei",6,"180");var person2 = creatPerson("kuo",8,"160");console.log(person1)//Object &#123;name: "wei", age: 6, height: "180", showName: function&#125;console.log(person2)//Object &#123;name: "kuo", age: 8, height: "160", showName: function&#125;console.log(person1.showName)//function () &#123; alert(this.name) &#125;console.log(person2.showName)//function () &#123; alert(this.name) &#125;上面都没有问题，在看下面这个console.log(person1.showName==person2.showName)//false这里是不一样的，这样的话创建一百个对象就会出现一百种方法岂不是很浪费内存。 工厂模式的缺点：方法不一样浪费内存，也不知道对象的类型，还有就是感觉创建对象没有使用new感觉很不爽啊。 创建对象-构造函数模式构造函数与其他函数的区别就是调用方式不同，单是构造函数也是函数，不存在其他语法。 任何函数只要通过new操作符来调用，那就可以作为构造函数123456789101112131415function Person (name,age,height)&#123; this.name = name; this.age = age; this.height = height; this.showName = function () &#123; alert(this.name) &#125;&#125;var person1 = new Person("wei",6,"180");var person2 = new Person("kuo",8,"160");console.log(person1)//Person &#123;name: "wei", age: 6, height: "180", showName: function&#125;console.log(person2)//Person &#123;name: "kuo", age: 8, height: "160", showName: function&#125;但是console.log(person1.showName==person2.showName)false还是false,说明这个问题和上面的一样了，但是代码变少了。 我们来比较一下工厂模式和构造函数的不同之处。12341.没有明确的创建对象；2.直接将属性和方法赋值给了this对象；3.没有return语句了；*在这里要主意一点：构造函数应该以一个大写字母开头可以和其他函数区分开 要创建Person的心实例，必须使用new操作符。这种方式调用构造函数会经历以下4步。12341.创建一个新对象；2.将构造函数的作用域赋给新对象（this就指向了这个对象）；3.执行构造函数中的代码（为这个性对象添加属性）；4.返回新对象； person1和person2分别保存着Person的一个不同的实例，这两个对象都有一个constructor(构造属性)12console.log(person1.constructor == Person)//trueconsole.log(person2.constructor == Person)//true 再用instanceof检测一下类型1234console.log(person1 instanceof Object)//trueconsole.log(person1 instanceof Person)//trueconsole.log(person2 instanceof Object)//trueconsole.log(person2 instanceof Person)//true 例子中创建的所有对象即是Obect的实例，也是Person的实例。 构造函数的缺点：每个方法都要在每个实例上重新创建一遍，浪费内存。 创建对象-原型模式我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有势力共享的属性和方法。是不是很深奥 简化一下propotype就是通过调用构造函数而创建的那个对象实例的原型对象，使用原型对象好处是可以让所有对象实例共享他所包含的属性和方法。 在简单点比如一个页面有10个div，我想把他们背景都变成红色，怎么办，给每一个div都加上内联样式style=”background:red;”,麻烦不麻烦，这样我们起一个class名.red{ background:red;}给每一个div都加上.red的class名就好了，原型就相当于类名，这样理解起来就好理解了。12345678910111213function Person()&#123;&#125;Person.prototype.name = "wei";Person.prototype.age = 6;Person.prototype.height = 180;Person.prototype.showName = function () &#123; alert(this.name);&#125;var person1 = new Person();person1.showName();//weivar person2 = new Person();person2.showName();//weiconsole.log(person1.showName == person2.showName)//true 也可以简化为这样123456789101112131415function Person()&#123;&#125;Person.prototype = &#123; name : "wei", age : 6, height : 180, showName : function () &#123; alert(this.name); &#125;&#125;var person1 = new Person();person1.showName();//weivar person2 = new Person();person2.showName();//weiconsole.log(person1.showName == person2.showName)//true 再来看一个例子1234567891011121314151617function Person()&#123;&#125;Person.prototype = &#123; name : "wei", age : 6, height : 180, friends : ["xiao","zhang"], showName : function () &#123; alert(this.name); &#125;&#125;var person1 = new Person();var person2 = new Person();person1.friends.push("meng")console.log(person1.friends)//["xiao", "zhang", "meng"]console.log(person2.friends)//["xiao", "zhang", "meng"]console.log(person1.showName === person2.showName)//true 一下就看出问题来了吧，我想改的改了，不想改的也给我改了。 原型模式的缺点：太共享了，没有自己的隐私。 创建对象-混合模式混合模式就是将构造函数模式和原型模式组合起来一起使用，这种自定义类型是ECMAscript中使用最广泛的、认同度最高的。 构造函数模式用于定义实例属性，原型模式用于定义方法和公共的属性。再来看一个例子12345678910111213141516171819function Person (name, age, height) &#123; this.name = name; this.age = age; this.height = height; this.friends = ["xiao", "zhang"];&#125;Person.prototype = &#123; showName : function () &#123; alert(this.name) &#125;&#125;var person1 = new Person("wei", 6, 180)var person2 = new Person("kuo", 8, 160)person1.friends.push("meng")console.log(person1.friends)//["xiao", "zhang", "meng"]console.log(person2.friends)//["xiao", "zhang"]console.log(person1.friends === person2.friends)//falseconsole.log(person1.showName === person2.showName)//true 混合模式每个实例都会有自己的一份实例属性的副本，但同时游共享着对方的引用，最大限度的节省了内存，混合模式还支持向构造函数传递参数，集合了两种模式的优点。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codepen]]></title>
    <url>%2F2017%2F06%2F01%2Fcodepen%2F</url>
    <content type="text"><![CDATA[codepen, “代码笔”,前端开发很好用的一个网站，你可以把你的HTML、css、js代码放到上面看效果，也可以在上面直接写代码看结果。 现在的css3的一些特效，像旋转，移动什么的都需要进行兼容性处理，在这里就介绍一下codepen如何进行兼容性处理。 首先打开codepen网址，www.codepen.io点击creat新建一个newpen把css代码粘贴到css框里，然后这样css代码框里的兼容就处理好了，就可以替换原来的代码了。 看一下兼容前后的效果！看着很简单，但是一个页面有很多css动画，还有很多个页面，这个兼容就好用多了。 codepen的实用之处。。。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>codepen兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js和jq获取当前位置]]></title>
    <url>%2F2017%2F05%2F24%2Fwidth%2Bheight%2F</url>
    <content type="text"><![CDATA[在写javascript的时候，有的时候需要判断盒子的当前位置，或者鼠标位置，在这里我就总结一下这些判断方法，先来一张直观图。1234567891011121314151617181920212223javascript原生写法BODY对象宽度：document.body.clientWidthBODY对象高度：document.body.clientHeight可见区域宽度：document.documentElement.clientWidth可见区域高度：document.documentElement.clientHeight网页可见区域宽：document.body.offsetWidth (包括边线的宽)网页可见区域高：document.body.offsetHeight (包括边线的高)网页正文全文宽：document.body.scrollWidth网页正文全文高：document.body.scrollHeight网页被卷去的高：document.body.scrollTop网页被卷去的左：document.body.scrollLeft网页正文部分上：window.screenTop网页正文部分左：window.screenLeft屏幕分辨率的高：window.screen.height屏幕分辨率的宽：window.screen.width屏幕可用工作区高度：window.screen.availHeight屏幕可用工作区宽度：window.screen.availWidth获取元素的宽度：obj.clientWidth元素的高度：obj.clientHeight偏移坐标left：obj.offsetLeft偏移坐标top：obj.offsetTop元素的宽度：obj.offsetWidth元素的高度：obj.offsetHeight 1234567jquery写法偏移坐标left：$(selector).offset().left偏移坐标top：$(selector).offset().top宽度：$(w).height() //可试区域w=window、页面的文档w=documene、元素w=obj高度：$(h).width(); //可试区域h=window、页面的文档h=documene、元素h=obj滚动高度：$(document).scrollTop()滚动宽度：$(document).scrollTop() 123js原生+jquery写法偏移坐标left：$(selector)[0].offsetLeft偏移坐标top：$(selector)[0].offsetTop 2018-12-03更新今天发现一个新的js方法，可以直接返回好多东西，来看一下。语法是Element.getBoundingClientRect();看一下取到的值返回值是一个 DOMRect 对象，我们想使用哪个值直接点上哪个就好了。比如1234const el =document.getElementById('police_deviation')const bound=el.getBoundingClientRect()bound.left //元素距离页面左侧值bound.right //元素距离页面右侧值 具体看下图详细的也可以看这里https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect 在看一下兼容性good ！！！！！！可以直接拿来用了。 持续更新。。。。。。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js和jq判断位置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github pages+jekyll搭建博客(windows)]]></title>
    <url>%2F2017%2F05%2F16%2Fgithub%20pages%2Bjekyll%2F</url>
    <content type="text"><![CDATA[前言先唠叨两句，说一下我的写博客经历，原来我就是在新浪写一写，后来发现对于程序员来说，并不是很好用，一些代码他会过滤，还会给你读出来，上次有一个input框，发布出去的时候居然出来一个搜索框，让我无言以对。代码高亮什么的效果都不好，还需要我把代码放到记事本里，在粘贴到博客里，很麻烦，也不美观，让后我就去博客园等一些地方，想在这些地方写写，后来想想觉得也不是很好，要不就自己做一套吧，我就用phpcms+bootstraps在本地搭建了一套，然后我觉得有点麻烦，写点什么也不方便，不直观，在加上还要去买服务器，然后就放弃了。后来发现了这个github pages感觉很不错，就像写txt是的，很方便，在加上一套jekyll模板，感觉还是很不错的，现在还很流行Hexo,下面有一块我会对比一下jekyll和Hexo的区别，优缺点。 一、github pages和jekyll介绍首先先介绍一下github pages和jekyll github pages其实就是github可以的为项目建立介绍站点，也可以用来建立个人博客的一个地方。个人觉得其实和新浪博客差不多。 jekyll是一款比较流行的静态博客框架其他的还有Jekyll，Hexo，Simple，Octopress，Pelican以及Lo·gecho等等。这些静态程序可以说都有各自的好处。在这里我就比较一下jekyll和Hexo 1.Jeky基于Ruby实现，安装Jeky需要搭建Ruby环境，在Windows搭建Ruby环境并不是被推荐的，而 Hexo基于NodeJs实现，在Windows上安装NodeJs开发环境简单。 2.Jekyll没有本地服务器，无法实现本地博文预览功能，需要上传到WEB容器中才能预览功能，而Hexo可以通过简单的命令实现本地的预览，并直接发布到WEB容器中实现同步。 3.比较直接的另一个原因是在网上查找了很多博客的主题，发现Jekyll官网提供的主题都不怎么好看(可能是个人原因)，而Hexo的主题看的比较顺眼。 4.两者都支持Markdown语法。 比较了一下感觉Hexo更好哈，我选择了jekyll的原因是因为当我选择了用github pages做博客的时候，官方推荐的就是jekyll,让后又看到了黄玄Hux Blog的博客，感觉他的模板很不错，所以就选择了使用jekyll。看完这篇文章，相信想用Hexo也方便理解很多。 二、jekyll安装和配置其实你不在本地安装jekyll也可以的，在本地安装的好处就是你在本地写的代码可以随时查看，修改，监测，而不需要在传到github上，这样太麻烦了。 要安装jekyll首先需要安装ruby下载地址下载好了之后就是一路的next,可以根据个人选择安装到那个盘，选择相应的位数进行下载。进行到这一步的时候把第二个选上，安装一下环境，当然全选也无所谓哦，安装好之后就可以不管他了，后面也用不到，但是没有他还真不行。安装好ruby之后就是安装RubyDevKit下载地址和ruby的地址是一个，只需要往下拉就可以看到这个画面,在这里要注意一点ruby2.0以上的版本从下面两个下载，还有一点你ruby安装的32位在这就要下载32位,64位就下载64位。最好安装最新的吧。位置最好和ruby在相同的盘里。都安装好之后就要进行配置了，首先打开安装的RubyDevKit的文件夹cmd进入（小黑框！！）输入命令1ruby dk.rb init 此时看一下你的RubyDevKit文件夹会生成一个config.yml配置文件，记录了系统安装ruby的位置。然后是就要开始安装jykell了，首先要把安装源变为国内的。删除旧的安装源：1gem sources --remove https://rubygems.org/ 添加新的安装源：1gem sources -a http://gems.ruby-china.org/ 不放心的话可以确认一下安装源：1gem source -l 开始安装jekyll1gem install jekyll 安装成功后就是要写我们的博客了，在这建议大家去网上找一找好看的模板直接fork下来，这样方便快捷，非常省时间，在这里我要感谢黄玄Hux Blog，我就是从他这里fork的，欢迎借鉴参考。 找到一个好的模板fork下来之后，把文件夹名字改为githubname.github.io(比如我的就叫zywkuo.github.io)一个基本的 Jekyll 网站的目录结构一般是像这样的：123456789101112131415161718.├── _config.yml├── _drafts| ├── begin-with-the-crazy-ideas.textile| └── on-simplicity-in-technology.markdown├── _includes| ├── footer.html| └── header.html├── _layouts| ├── default.html| └── post.html├── _posts| ├── 2007-10-29-why-every-programmer-should-play-nethack.textile| └── 2009-04-26-barcamp-boston-4-roundup.textile├── _data| └── members.yml├── _site└── index.html 来看看这些都有什么用：12345678_config.yml 存储配置数据。很多全局的配置或者指令写在这里。_drafts 存放为发表的文章。这些是没有日期的文件。_includes 你可以加载这些包含部分到你的布局或者文章中以方便重用。_layouts 布局、模板。_posts 存放写文章，格式化为：YEAR-MONTH-DAY-title.md。_site 最终生成的博客文件就在这里。index.html 博客的主页。other 例如静态文件 CSS，Images 和其他。 进入这个文件夹再次使用cmd(小黑框)，运行命令1jekyll serve 当我运行启动服务器的命令的时候办了这个错误12 Dependency Error: Yikes! It looks like you don't have jekyll-paginate or one of its dependencies installed. In order to use Jekyll as currently configured, you'll need to install this gem. The full error message from Ruby is: 'cannot load such file -- jekyll-paginate' If you run into trouble, you can find helpful resources at https://jekyllrb.com/help/!jekyll 3.4.3 | Error: jekyll-paginate 只需要在输入这个，回车就可以了1gem install jekyll-paginate 再次输入无错误提示就说明服务器已经运行成功了，如果还有其他错误请自行百度吧。1jekyll serve 此时打开浏览器在地址栏输入下面的网址就可以看到你的博客了1localhost:4000或127.0.0.1:4000 在写自己的博客的时候需要多次的去浏览器看博客在网页上的显示情况只需要输入下面的就可以对你的代码就行实时监测，实时更新了。1jekyll serve --watch 当要写博客的时候只需要在_posts文件夹下新建一个.markdown的文件，次文件的命名要遵循这个原则。不能更改的。1年-月-日-标题.markdown 三、github pages仓库建立想要用github pages必须自己要有一个github账户这个不用多说了。进入到自己的github账户后，首先建立一个新的仓库，名称与本地的文件夹名称一样。1githubname.guthub.io(我的就是zywkuo.github.io) 因为我已经建好了，所以显示已有。 四、将写好的博客放到github仓库上在本地我们使用jykyll写好的博客，就可以放到，github上刚刚新建好的那个仓库这里，如何显示网页就交个giuhub吧，其实就是github上就有自带的jekyll,他会自动生成静态页的。 在做这一步的时候就需要会一些git指令了，并且还需要下载git(这个要是不会，度娘一下把。) 下载好了之后进入本地的githubname.github.io的文件夹，右击git bash(安装好git右击就会有的),初始化本地仓库：12$ git init注：git指令在输入的时候不需要加$，在执行每条指令自动加$,我是为了和上面的指令就行区分，所以git指令都加上了$ 然后将本地的代码上传到仓库第一次需要这样执行1234$ git add .$ git commit -a -m "注释信息"$ git remote add origin https://github.com/username/repositoryname.git$ git push origin master 以后再上传就可以这样执行了123$ git add .$ git commit -a -m "注释信息"$ git push origin master 开始的时候我在网上发现之前有一些做法是需要创建一个叫做gh-pages的分支并且在这个分支进行操作，经过我的测试，可能这个适用于之前的版本，目前只需要将代码直接上传到主分支master就可以了。 此时你可以访问网址看看自己的博客了。1githubname.github.io(不要忘了换成自己的github名字) 五、绑定自己的域名在这里我就介绍如何绑定二级域名，一级域名绑定其实和二级的差不多，更加简单。首先找到自己github上新建的那个githuname.github.io的仓库进入到设置页面往下拉找到这个位置在input框里输入域名，blog.lihaikuo.com.一级域名就直接输入lihaikuo.com就可以了你需要在根目录新建一个文件名为CNAME的文件，这个文件不需要添加任何后缀，在文件里写上bolg.lihaikuo.com(顶级域名就写lihaikuo.com)，让后上传到github上githubname.github.io的仓库上然后去你购买的域名网站去进行域名解析，我的域名是在百度云上买的，在域名解析页面添加一条这样的解析指令12添加一个CNAME，主机记录写blog，后面记录值写上你的zywkuo.github.io.blog CNAME githubname.github.io.（最后面还有一个‘.’不要忘记） 一级域名主机记录写www就好了。如果不可以，在加上这两条解析就OK了。12@ A 192.30.252.153@ A 192.30.252.154 等上10分钟，访问一下你的网址看看成效吧—–&gt;blog.lihaikuo.com 注：此篇博客发表时间2017-05-16，随着时间迁移，或许会越来越方便，最近观看的小伙帮肯定没问题，以后有可能会改版，就像我在找资料的时候也走进了很多坑。希望小伙伴们多多注意。 Finally, thanks for reading]]></content>
      <categories>
        <category>github pages</category>
      </categories>
      <tags>
        <tag>github pages+jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Zyw]]></title>
    <url>%2F2017%2F05%2F12%2Fhello-zyw%2F</url>
    <content type="text"><![CDATA[之前在新浪写博客，现在搬家都这里，发一个短片的小博客，庆祝我的技术博客搬家。]]></content>
      <tags>
        <tag>github博客</tag>
      </tags>
  </entry>
</search>
